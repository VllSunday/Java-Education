---
создал заметку: 2024-09-02
---
Что такое транзакция? 


Это единица работы в рамках соединения с базой данных.
Другими словами: если мы хотим отправить SQL запрос из нашего клиента в нашу базу данных, то мы обязаны открыть транзакцию.

PoostgreSQL создает транзакции автоматически(это можно настроить)

У транзакции всего есть 2 состояния: 

Либо, выполняется полностью и происходит (<font color="#ff0000"><span style="background:#ff4d4f">commit</span></font>)
Либо, полностью откатывается и происходит (<span style="background:#ff4d4f">rollback</span>)

### Atomicity
Атомарность гарантирует, что никакая транзакция не
будет зафиксирована в системе частично
Будут либо выполнены все её подоперации,
либо не выполнено ни одной

### Consistency
Согласованность - каждая успешная транзакция
фиксирует только допустимые результаты

### Isolation
Изолированность - во время выполнения транзакции
параллельные транзакции не должны оказывать
влияние на ее результат

### Durability
Устойчивость - независимо от проблем на нижних уровнях
изменения, сделанные успешно завершённой транзакцией,
должны остаться сохраненными после возвращения
системы в работу

Устойчивость добивается различными способами, основной это Lock Table

То есть по мимо нашей основной таблицы, еще есть Lock таблица, которая хранит info о изменениях которые были сделаны в бд. Благодаря этим таблицам мы можем восстановить, данные который могли потерять 


### Transaction isolaiton issues 

Из за того что транзакции работают параллельно могут возникать разные не предвиденные случаи.

Их всего 4, и идут в порядке сложности: 

1. Lost Update - потерянное обновление
2. Dirty Read - "грязное" чтение 
3. Non Repeatable Read - не повторяющееся чтение 
4. Phantom Read - фантомное чтение

### 1)Last Update
Происходит, когда обе транзакции одновременно обновляют
данные и затем вторая транзакция откатывает изменения,
вследствие чего изменения обеих транзакций теряются
![[Pasted image 20240904200959.png]]

Например, у нас есть Tx A и Tx B, 

Tx А обновляет данные, например стоимость билета с 5 на 12 долларов. 
А Tx B изменяет стоимость с 5 на 15 долларов.
Потом завершается Tx А и изменяет значение билетов. 
Затем Tx B пытается изменить, и видит что то произошло с данными. 
Происходит RollBack до изначальных 5 долларов. Причем изменения <font color="#00b050">коснуться не только Tx B но и Tx A</font>. То есть все транзакции будут возвращены к изначальному уровню

В современных базах данных эта аномалия предусмотрена, например в PostgreSQL этот вариант не возможно продемонстрировать.

### Dirty Read
Происходит, когда первая транзакция читает изменения, сделанные
другой транзакцией, но эти изменения еще не были ей закомичены.
После чего вторая транзакция откатывает эти изменения, а первая
продолжает работу с «грязными» данными

![[Pasted image 20240904202020.png]]

Проблема в том что транзакция В обновила данные о цене билета, и до того как эта транзакция сделала RollBack эти данные считала другая транзакция. Это и называется Dirty Read то есть, транзакция А работает теперь с не валидными данными. 




### Non Repeatable Read
Происходит, когда первая'транзакция читает одни и те же данные
дважды, но после первого прочтения вторая транзакция изменяет
(update, очень важно что именно update а не что то другое) эти же данные и делает коммит, вследствие чего вторая
выборка в первой транзакции вернет другой результат

![[Pasted image 20240904202411.png]]
То есть проблема связана с тем что пока одна транзакция считала данные, другая (более быстрая) успела обновить данные. Когда 1 транзакция еще раз обращается к данным то видит что данные отличаются от тех что были в начале. Это будет считаться аномалией


### Особый случай в Non Repeatable Read(last commit wins)

Существует особый случай Non Repeatable Read называемый last
commit wins, когда обе транзакции читают одни и те же данные, но
первая успевает изменить и захомутать их раньше, чем произойдет
изменение и коммит во второй транзакции, вследствие чего
изменения первой транзакции теряются

![[Pasted image 20240904202926.png]]
Тут проблема заключается в том что, обе транзакции считывают по 5 долларов. 
Первая меняет эту цена на 5+5 = 10.
Вторая меняет эту цену на 5+7 = 12.
И как показано на примере, 1 транзакция закончилась быстрее и изменила значение на 10
То потом (чуть позже) 2 транзакция изменила значение на 12. Получается что 1 транзакция будет затерта и потеряется. Останется 12 

Для того что бы решить эту проблему будет достаточно заблокировать строки которые были обновлены, что бы их не кто не тронул
### Phantom Read
Происходит, когда первая транзакция читает одни и те же данные
дважды, но после первого прочтения вторая транзакция добавляет
новые строки или удаляет старые и делает коммит(в данном случае именно <font color="#ffff00">добавляет</font> или <font color="#ffff00">удаляет</font> строки, не нужно путать с Non Repeatable Read где происходит именно <font color="#ffff00">обновление</font>, вследствие чего
вторая выборка в первой транзакции вернет другой результат
(разное количество записей)
![[Pasted image 20240904203820.png]]

Для того чтобы решить эту проблему мы не может заблокировать строки, потому что они не обновляются у добавляются или удаляются. 
Мы лишь можем заблокировать всю нашу таблицу. Для того чтобы наши выборки были одинаковы и в конце ее 


### Isolation level 
![[Pasted image 20240904204258.png]]

Чем выше уровень тем ниже performance но выше consistancy 
И на оборот 

Это происходит потому что с каждым новым уровнем транзакции. Работа в много поточной среде становиться все сложнее и сложнее. По этому скорость работы падает но вырастает уровень согласованости(consistancy)

В случае с SERIALIZABLE мы вообще не можем обрабатываться паралельно данные из 1 таблицы.


### Transaction level in PostgreSQL 

![[Pasted image 20240904204856.png]]

В PostgreSQL есть только 2 уровня транзакции

- Read Commited (by default)
- Serializable 


