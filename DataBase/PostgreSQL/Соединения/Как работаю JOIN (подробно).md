---
создал заметку: 2024-08-10
---
# Основный отличия INNER от OUTER JOIN 

- **INNER JOIN** возвращает только совпадающие строки.
- **OUTER JOIN** возвращает все строки, которые совпадают, и те, которые не имеют совпадений, с заполнением `NULL` для отсутствующих данных.


## Пример работы `JOIN` с использованием условия `students.student_id = courses.student_id`

### Таблицы и их структура

**Таблица `students`:**

| student_id | name      |
|------------|-----------|
| 1          | Alice     |
| 2          | Bob       |
| 3          | Charlie   |

**Таблица `courses`:**

| course_id | student_id | course_name    |
|-----------|------------|----------------|
| 101       | 1          | Math           |
| 102       | 1          | Physics        |
| 103       | 2          | Chemistry      |
| 104       | 4          | Biology        |

### Что такое `student_id`?

- `student_id` в таблице `students` — это уникальный идентификатор (например, первичный ключ), который однозначно идентифицирует каждого студента.
- `student_id` в таблице `courses` — это внешний ключ, который указывает на студента, записанного на конкретный курс.

Таким образом, `student_id` выступает в роли связующего элемента между таблицами `students` и `courses`.

### Как работает сопоставление?

Теперь рассмотрим, что происходит, когда мы выполняем `JOIN` с условием `students.student_id = courses.student_id`.


SELECT students.name, courses.course_name
FROM students
INNER JOIN courses ON students.student_id = courses.student_id;


#### Этапы выполнения запроса:

1. **Сканирование таблиц**:
   - Сначала PostgreSQL загружает все строки из обеих таблиц (`students` и `courses`).
   
2. **Поиск совпадений**:
   - Для каждой строки из таблицы `students` база данных ищет строки в таблице `courses`, где значение в столбце `student_id` совпадает с `student_id` из таблицы `students`.
   - Например, возьмем первую строку из таблицы `students`: `student_id = 1`, `name = Alice`.
   - Теперь PostgreSQL смотрит на все строки в таблице `courses` и ищет строки, где `student_id` равен `1`.

3. **Создание результата**:
   - После того как совпадения найдены, PostgreSQL объединяет данные из обеих таблиц в одну результирующую строку.
   - Например:
     - Для строки `student_id = 1` из таблицы `students` (где `name = Alice`), в таблице `courses` найдены две строки, где `student_id = 1` (это строки с `course_name = Math` и `course_name = Physics`).
     - PostgreSQL создает две результирующие строки:
       - Первая: `name = Alice`, `course_name = Math`.
       - Вторая: `name = Alice`, `course_name = Physics`.

4. **Повторение для всех строк**:
   - PostgreSQL повторяет этот процесс для каждой строки из таблицы `students`.
   - Когда доходит до строки `student_id = 2` и `name = Bob`, база данных находит строку в `courses` с `student_id = 2` и создает строку в результирующей таблице: `name = Bob`, `course_name = Chemistry`.

5. **Итог**:
   - После выполнения запроса, результирующая таблица будет выглядеть так:

   | name   | course_name |
   |--------|-------------|
   | Alice  | Math        |
   | Alice  | Physics     |
   | Bob    | Chemistry   |

### Ответ на твой вопрос

**Как id и имена сопоставляются?**

Мы используем `student_id` как связующий элемент, который помогает базе данных понять, какие строки в одной таблице соответствуют строкам в другой таблице.

- **Сопоставление происходит по `student_id`**: `JOIN` связывает строки на основе идентификаторов, и в результате этого соединения ты получаешь доступ ко всем полям из обеих таблиц.
  
- **Работа с именами**: В результирующей таблице ты можешь включить любые столбцы, включая имена. Таким образом, используя `student_id` как мост между таблицами, ты можешь получить список имен студентов и соответствующих им курсов.

### Важное замечание

- `student_id` служит уникальным идентификатором, который гарантирует, что каждый студент правильно сопоставлен с его курсами. Без такого идентификатора или без другого связующего элемента `JOIN` не знал бы, какие строки нужно объединять.

---

Надеюсь, теперь стало более понятно, как происходит сопоставление и как работают `JOIN`-ы в SQL! Если остались вопросы, не стесняйся спрашивать.


Этот формат оптимизирован для использования в Obsidian с заголовками, таблицами и блоками кода, которые будут легко читаться и помогать в изучении материала.