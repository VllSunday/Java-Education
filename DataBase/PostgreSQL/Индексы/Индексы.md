---
создал заметку: 2024-08-27
---
==Индекс== - это структура данных, ускоряющая
выборку данных из таблицы за счёт доп. операций записи
и пространства на диске, используемых для хранения
структуры данных и поддержания её в актуальном состоянии.

<font color="#a5a5a5">Короче говоря ==индекс==, это структура данных которая ускоряет выборку данных.</font>
<font color="#a5a5a5">Сам по себе индекс это структура данных так же которая позволяет ускорить выборку данных из таблицы, которая где то храниться </font>

### Что такое - Database cluster? 
Database cluster - одна и более БД, управляемые из под одной инстанции сервера. 
Когда мы установили PostgreSQL мы получили кластер, который стразу же был создан со специальными базами данных. Postgres (утилитарной) & DB Template1 (специализированная база данных) которая создается при создании кластера,  которая используется для того что бы создавать новые базы данных. Когда мы создаем новую базу данных. Tamplate1 клонируется, и таким образом появляется наша новая база данных.

### Где лежат данные кластера?
Файлы данных кластера лежат в директории data (часто называемой PGDATA)
Для каждой БД есть своя подпапка в PGDATA/base.
Вообще там есть масса под папок, где хранятся файлы с информацией о транзакциях,  множестве утилитарных функций используемых сервером для обеспичением своих основных функций и тд.

В том числе там хранятся данные о таблицах и индексах.

Для каждой таблицы и индекса выделяется отдельный файл.
Интересная информация: файлы по умолчанию бьются на сегменты по 1 гб.
То есть когда превышается этот размер то создается еще 1 файл. Естественно сервер об этом в курсе, + это можно настроить.


### Устройство БД 

- Таблица состоит из массива станиц (блоков, размером 8кб)
- Файл таблицы называется Heap File содержит списки неупорядоченных записей различной длины. Вообще страничные сегменты могут быть и других размерова, не только 8 кб. Это размер по умолчанию. Стоит обратить внимание что в данном случае Heap к структуре данных куча особого отношения не имеет, он структурирован как набор страниц, каждый из которых содежит множество строк.

![[Pasted image 20240827201950.png]]

CTID - состоит из пары значений: номер страницы и индекса. Используя эту мета информацию PostgerSQL умеет быстро обращаться к данным, хранящихся в тех или иных местах.

Что касается 8 кб. 8 кб не означает что в строке не может быть гиганских значений привышающих 8 кб. Это не достигается за счет хранения строки в разных страницах. Как раз 
запрещено и сервером не поддерживается. 

Если в столбце строки имеется такое значение которое превышает, собственно сам размер страницы, где должно лежать n-е кол-во записей. Так вот если имеется такое значение, то подобная ситуация обрабатывается с помощью механизма TOAST - the oversized attribute storage technique. Каждая таблица имеет ассациированную с ней TOAST таблицу, в которой хранятся большие значение нарезанные по 2 кб. А в столбце исходной таблицы, помещается ссылка на место в TOAST таблице, где храниться реальное значение.

В общем все как обычно, введите новый слой абстракции, и этот подход решит все проблемы, за исключением слишком большого кол-ва абстракций.

---

Рядом с файлом таблицы лежит файл FSM (free space map) - он хранит значения округленные до 1 до 256 от размера страницы, это 32 байта, при размере страницы в размере 8 кб. Используется он для того, что бы север понимал. Куда можно сохранить данные определенных размеров. А не бегал по страницам в лехарадочном поиске, достаточного отрезка памяти. 

При этом важно заметить что FMS не обновляется при каждом обновлении или удалении строк (это достаточно правильное решение)
Поскольку на самом деле, при удалении или обновлении строки, ее старая версия, не исчезает мгнованно из памяти. Так происходит для того , что бы поддерживать механизм конкурентного доступа , к одним и тем же данным(параллельного) 

Есть такая команда VACUUM `[FULL]` - команда для очистки "дохлых" версий строк.
Как мы помним из прошлого абзаца строки не удаляются сразу.
Так вот команда VACUUM призвана для того чтобы очищать дохлые версий строк (это все равно нужно делать, иначе не какой памяти не хватит)
Важно также сказать что VACUUM не удаляет эти строки из памяти. Он просто помечает их как те которые можно перезаписывать новыми данными. 
VACUUM FULL производит сжатие таблицы, и полную ее перезапись. Проводя по факту дефрагмантацию данных. Это долго и требует примерно столько же памяти сколько занимает таблица, на которую натравили VACUUM FULL (по этому VACUUM FULL) делается редко.


Рядом с файлом таблицы лежит файл VM (visibility map) - эти файлы хранят биты. 
1 бит на страницу. Которые будучи выставленными в 1 показывает что страница, протухших версий строк. Это также является 1 из механизмов  отпимизации


- Если вообще не обслуживать БД, то фрагментация данных будет нарастать

- VACUUM - команда для очистки «дохлых» версий строк

- VACUUM FULL - полный «компактинг» таблицы
  одним из значительных недостатков является то что VACUUM FULL берет экслюзивную блокировку на запись и чтение в таблице. а обычный VACUUM такую блокировку не берет и работает парраллельно 

- Необходим периодический запуск VACUUM

- Активно обновляемым БД рекомендуется проходить VACUUM каждую ночь

- VACUUM FULL только если удалили много данных

- VACUUM ANALYZE - комбинация двух операций

- Autovacuum демон делает всё автоматически
  По умолчанию запускается для всех таблиц в БД. Но можно и натравить на конкретную таблицу. <font color="#ff0000"><span style="background:#ff4d4f">Не рекомендуется отключать</span></font>



### Индексы

<span style="background:#ff4d4f">Индекс -структура данных, ускоряющая</span>
<span style="background:#ff4d4f">выборку данных из таблицы за счёт доп. расходов</span>

2) Позволяет искать значения без полного перебора
- Также индексы называют методами доступа, потому что в конечном счете индекс устанавливает соответствие между ключом являющимся по обыкновению значением проиндексированного столбца(проще говоря индексом), и строками таблицы в которых этот ключ встречается. То есть индекс устанавливает соответствие между ключом и строками таблицы в которых этот ключ встречается. 
- Можно встретить такую аббревиатуру - TID (или тьюпл id)
  Так вот строки идентифицируются с помощью этих TID. Которые состоят из номера блока файла и позиции строки внутри блока.

- Так вот как мы избегаем этого полного перебора? 
  Зная ключ, или информацию о нем (а эта информация и храниться с структуре данных индекс) можно быстро прочитать те строки, в которых может находиться интересующая нас информация, не просматривая всю таблицу полностью. 

3) Оптимизация выборки «небольшого» числа записей
- От того сколько записей фильтрует запрос, будет зависеть будет ли использован индекс, или полное сканирование таблицы. Что вообще значит не большое число записей? 

4) "Небольшое" - число относительно кол-ва записей содержащихся в таблице 

5) По PRIMARY KEY и UNIQUE(всм UNIQUE ограничение когда мы создаем на столбце) столбцам индекс создается автоматически 
- Забегая вперед будет создовать так называемый B-tree индекс. То есть сбалансированное дерево, то есть структура данных используемая для построения такого индекса - сбалансированное дерево (B-tree(Balanced Tree))
6) Надо сказать что индексы не бесплатны
   - Индексы требуют определенных затрат, на свое поддержание.
   - При любой операции, над про индексированными данными, будь то вставка, удаление, или обновление строк таблицы. Индексы созданные для этой таблицы должны быть перестроены! Причем в рамках той же транзакции. Надо заметить что обновление полей таблицы, по которым не создавались индексы, не приводят к построению индексов. Этот механизм называется <span style="background:#ff4d4f">HOT</span> (Heap Only Tuple)


### Виды индексов в PostgreSQL 

Если подключиться к любой базе данных, в нашем кластере, и выполнить запрос 

```sql
SELECT amname 
FROM pg_am;
```
Какие типы индексов доступны на сервере.

Как правило это будут следующее типы:  

1) B-tree (сбалансированное дерево)
2) Хеш-индекс
3) GiST (обобщённое дерево поиска)
4) GIN (обобщённый обратный)
5) SP-GiST (GiST с двоичным разбиением пространства)
6) BRIN (блочно-диапазонный)


### Методы сканирования

- Индексное (index scan)
     Если есть большой набор, проиндексированных данных и мы осуществляем  поиск по индексу и потенциально и результирующий набор попадает малое кол-во строк. Например: всего 1 строка, а в таблице содержится 1 миллион строк. То оптимизатор включит индексный поиск. Включение тех или иных методов сканирования, находиться в епархии оптимизатора. Именно оптимизатор, решает включать ли какие то методы поиска или исключать. В каком случае будет работать индексный метод сканирования? 
     Например: мы ищем строку по конкретному цела численному значению, некому id в проиндексированном столбце. На миллион записей в которых все id уникальны. Попадет всего лишь единственная строка. В таком случаем опримизатор, почти наверника включит индексный поиск. 
 
### 1. **Введение в методы сканирования**
   - **Лирическое отступление**: Краткое объяснение перед тем, как перейти к обсуждению индексов.
   - **Типы методов сканирования**: Обзор различных методов сканирования данных в PostgreSQL.

2. **Индексное сканирование**
   - **Когда используется индексное сканирование**:  
     - Оптимально для больших наборов данных, когда поиск по индексу возвращает небольшое количество строк (например, одну строку из миллиона).
     - Оптимизатор запросов решает, когда использовать индексное сканирование.
   - **Пример ситуации**: Поиск уникального целочисленного значения в проиндексированном столбце с большим объемом данных.

3. **Исключительно индексное сканирование (Index-Only Scanning)**
   - **Определение**: Некоторые индексы хранят проиндексированные значения вместе с идентификаторами строк, что позволяет извлекать данные непосредственно из индекса, минуя таблицы.
   - **Карта видимости**: 
     - Роль в обеспечении актуальности данных при исключительно индексном сканировании.
     - Важность выполнения команды `VACUUM` для поддержания эффективности исключительно индексного сканирования.
   - **Эффективность индексного сканирования**: Общая эффективность как исключительно индексного, так и обычного индексного сканирования.

4. **Сканирование по битовой карте (Bitmap Index Scanning)**
   - **Когда используется сканирование по битовой карте**: 
     - Подходит для случаев, когда запрос возвращает больше строк, чем при индексном сканировании, но меньше, чем при последовательном сканировании.
   - **Процесс**:
     - Метод создания битовой карты версий строк на основе совпадающих записей индекса.
     - Страницы данных читаются один раз, что снижает необходимость повторного доступа к тем же страницам.
   - **Преимущества**: Эффективно при использовании нескольких индексов и больших объемов данных.
   - **Версионирование строк в PostgreSQL**: 
     - Объяснение версионирования строк и его роли в сканировании по битовой карте.
     - Обеспечивает однократное чтение каждой страницы, минимизируя "прыжки" между страницами.

5. **Последовательное сканирование (Sequential Scanning)**
   - **Когда используется последовательное сканирование**: 
     - Индексное сканирование менее эффективно, когда условия запроса не являются селективными (например, при выборе большой доли строк).
   - **Рассмотрение затрат**: 
     - Последовательное сканирование может быть выбрано из-за меньших накладных расходов по сравнению с не селективным индексным сканированием.
   - **Влияние типа диска**:
     - Лучшая производительность при индексном сканировании на SSD благодаря меньшему времени поиска.
     - Проблемы производительности на обычных жестких дисках из-за частых перемещений головки.

6. **Выбор правильного метода сканирования**
   - **Роль оптимизатора**: 
     - Как оптимизатор PostgreSQL выбирает подходящий метод сканирования в зависимости от запроса и распределения данных.
   - **Применение на практике**: 
     - Анализ планов запросов, понимание различных методов сканирования и оптимизация запросов и индексов.
   - **Влияние на производительность запросов**: 
     - Как различные методы сканирования влияют на производительность, и какие шаги нужно предпринять для оптимизации.

7. **Заключение**
   - **Резюме**: Краткий обзор обсуждаемых тем, касающихся методов сканирования в PostgreSQL.
   - **Следующие шаги**: Анонс следующего видео из серии, где будет рассмотрено создание конкретных индексов.