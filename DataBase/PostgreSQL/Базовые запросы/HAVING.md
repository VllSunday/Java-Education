---
создал заметку: 2024-08-09
---
**Конечно, вот подробный конспект о операторе `HAVING` для сохранения в Obsidian. Я также объясню, зачем нужна вторичная сортировка и отличия между `WHERE` и `HAVING`.

---

## Оператор `HAVING` в SQL

Оператор `HAVING` используется в SQL для фильтрации результатов, которые были сгруппированы с помощью оператора `GROUP BY`. Он позволяет применить условия к группам строк, созданным после агрегации данных.

### Основной синтаксис

```sql
SELECT column1, aggregate_function(column2)
FROM table_name
GROUP BY column1
HAVING condition;
```

- `column1` - столбец, по которому производится группировка.
- `aggregate_function(column2)` - агрегатная функция, применяемая к данным в каждой группе.
- `condition` - условие для фильтрации сгруппированных данных.

### Примеры использования

#### Пример 1: Фильтрация сгруппированных данных

Таблица `sales`:

| product | amount |
|---------|--------|
| A       | 10     |
| A       | 20     |
| B       | 30     |
| B       | 40     |
| C       | 50     |

Запрос для нахождения продуктов, сумма продаж которых больше 40:

```sql
SELECT product, SUM(amount) AS total_amount
FROM sales
GROUP BY product
HAVING SUM(amount) > 40;
```

Результат:

| product | total_amount |
|---------|--------------|
| B       | 70           |
| C       | 50           |

#### Пример 2: Комбинация `HAVING` и `WHERE`

Если нужно сначала отфильтровать строки перед группировкой, а затем применить фильтрацию к сгруппированным данным:

```sql
SELECT product, SUM(amount) AS total_amount
FROM sales
WHERE amount > 15
GROUP BY product
HAVING SUM(amount) > 40;
```

В этом запросе сначала отбираются строки с `amount > 15`, затем данные группируются по `product`, и, наконец, применяются условия для сгруппированных данных.


__________________________________________________________________________________________
# Отличия между `WHERE` и `HAVING`

- **`WHERE`**: Применяется до агрегации данных, то есть фильтрует строки в таблице перед группировкой.
- **`HAVING`**: Применяется после агрегации данных, то есть фильтрует группы строк, созданные оператором `GROUP BY`.

### Примеры различий

- **`WHERE`**:

  ```sql
  SELECT product, amount
  FROM sales
  WHERE amount > 20;
  ```

  Этот запрос отбирает только те строки, где `amount > 20`, до выполнения группировки.

- **`HAVING`**:

  ```sql
  SELECT product, SUM(amount) AS total_amount
  FROM sales
  GROUP BY product
  HAVING SUM(amount) > 40;
  ```

  Этот запрос сначала группирует строки по `product` и затем фильтрует эти группы, чтобы оставить только те, у которых сумма продаж больше 40.

### Вторичная сортировка

Вторичная сортировка применяется, когда нужно упорядочить результаты по нескольким критериям. Например, после группировки данных и применения агрегатных функций можно отсортировать результаты по основному и вторичному критерию.

#### Пример вторичной сортировки

Таблица `sales`:

| product | amount |
|---------|--------|
| A       | 10     |
| A       | 20     |
| B       | 30     |
| B       | 40     |
| C       | 50     |

Запрос для группировки по `product`, суммирования `amount`, а затем сортировки сначала по `total_amount`, а затем по `product`:

```sql
SELECT product, SUM(amount) AS total_amount
FROM sales
GROUP BY product
HAVING SUM(amount) > 20
ORDER BY total_amount DESC, product ASC;
```

Результат будет отсортирован сначала по убыванию суммы продаж, а затем по возрастанию имени продукта:

| product | total_amount |
|---------|--------------|
| B       | 70           |
| C       | 50           |
| A       | 30           |

---
