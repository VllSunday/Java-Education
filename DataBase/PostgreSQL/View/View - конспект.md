---
создал заметку: 2024-08-15
---
Ты совершенно правильно понял основную концепцию представлений (VIEW) в PostgreSQL. Давай разберем, что такое представления, как они работают, и ответим на твои вопросы о их связи с таблицами и особенностях использования.

## Что такое VIEW?

**VIEW** в PostgreSQL — это виртуальная таблица, которая создается на основе SQL-запроса. Она хранит сам запрос, а не данные. Когда ты обращаешься к представлению, PostgreSQL выполняет хранимый запрос и возвращает результат как будто это была обычная таблица.

### Основные особенности VIEW:
- **Виртуальная таблица**: Представление не содержит собственных данных. Оно отображает данные в реальном времени, основываясь на результатах SQL-запроса, который его определяет.
- **Удобство использования**: Представления позволяют упрощать сложные запросы, избегая повторений кода и делая запросы более читаемыми.
- **Динамическое обновление**: Если данные в базовых таблицах изменяются, результаты представления также изменяются при следующем запросе к нему.

## Как VIEW связано с таблицами?

### 1. **Влияние изменений в таблицах на VIEW**:
- Когда данные в таблицах, на которые ссылается представление, изменяются (например, обновление, удаление или вставка новых строк), представление автоматически отразит эти изменения при следующем обращении.
- Представление всегда показывает актуальные данные, так как оно выполняет запрос в реальном времени.

### 2. **Влияние изменений в VIEW на таблицы**:
- **Представление само по себе не может напрямую изменять таблицы.** Это значит, что если ты изменишь структуру или условия выборки в представлении (например, добавишь столбец или изменишь фильтр), базовые таблицы останутся неизменными.
- Однако, если ты изменишь данные через представление (например, обновишь или удалишь строку), это изменение будет отражено в базовой таблице, при условии, что представление допускает модификацию данных (см. ограничения на модификацию).

### 3. **Фильтры и представления**:
- Если ты добавишь новые данные в базовую таблицу, которые не соответствуют условиям (фильтру) представления, эти данные не будут отображены в представлении. Это не означает, что данные не существуют в таблице — они просто не соответствуют условиям запроса, определяющего представление.

### Пример:

Предположим, у нас есть таблица `employees`, и представление `high_salary_employees`, которое отображает сотрудников с зарплатой выше 5000.

```sql
CREATE VIEW high_salary_employees AS
SELECT name, salary
FROM employees
WHERE salary > 5000;
```

- Если ты добавишь сотрудника с зарплатой 3000 в таблицу `employees`, он не будет виден в представлении `high_salary_employees`, потому что не соответствует условию `salary > 5000`.
- Если ты обновишь зарплату существующего сотрудника в таблице `employees`, и она станет больше 5000, то этот сотрудник появится в представлении.

## Вложенные представления

### 1. **Определение**:
- Вложенное представление — это представление, основанное на другом представлении. Например, если у тебя есть представление `view1`, ты можешь создать другое представление `view2`, которое использует `view1` как источник данных.

### 2. **Тонкости работы с вложенными представлениями**:
- **Производительность**: Чем больше уровней вложенности, тем сложнее запросы, которые PostgreSQL должен выполнить. Это может негативно сказаться на производительности, особенно если представления включают сложные запросы, агрегации или объединения.
- **Поддержка**: Вложенные представления могут усложнить поддержку кода, так как изменения в одном представлении могут непредсказуемо повлиять на другие представления, которые его используют.
- **Модификация данных**: Вложенные представления часто теряют возможность модификации данных, особенно если они используют конструкции, запрещенные для изменения (например, агрегатные функции, JOIN и т.д.).

### Пример:

Допустим, у тебя есть два представления:

```sql
CREATE VIEW employees_above_5000 AS
SELECT name, salary
FROM employees
WHERE salary > 5000;

CREATE VIEW highly_paid_salespeople AS
SELECT *
FROM employees_above_5000
WHERE department = 'Sales';
```

В этом случае `highly_paid_salespeople` будет показывать только тех сотрудников, у которых зарплата больше 5000 и которые работают в отделе продаж.

---

## Вывод

**Представления (VIEW)** — это мощный инструмент для создания абстракций над сложными SQL-запросами, который позволяет упростить работу с данными. Они не хранят данные сами по себе, а выполняют запросы в реальном времени, отражая актуальные данные из базовых таблиц.

**Важные моменты**:
- Представления динамически отображают изменения в базовых таблицах.
- Представления могут ограничивать видимость данных на основе условий.
- Вложенные представления полезны, но могут негативно сказаться на производительности и усложнить поддержку кода.

Надеюсь, этот разбор поможет тебе лучше понять, как работают представления и как их использовать в своих проектах.

---

# Представления (VIEW) в PostgreSQL

## 1. Создание и изменение представлений

### 1.1. Создание представления

```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

### 1.2. Изменение представления

- Представление можно изменить с помощью команды `CREATE OR REPLACE VIEW`:

```sql
CREATE OR REPLACE VIEW view_name AS 
SELECT new_column1, new_column2, ...
FROM table_name
WHERE new_condition;
```

- **Ограничения на изменения**:
  - **Добавление столбцов**: можно добавлять новые столбцы.
  - **Удаление столбцов**: нельзя удалять существующие столбцы.
  - **Переименование столбцов**: нельзя менять имена столбцов.
  - **Изменение порядка столбцов**: нельзя менять порядок следования столбцов.

## 2. Переименование и удаление представлений

### 2.1. Переименование представления

- Переименование выполняется с помощью команды `ALTER VIEW`:

```sql
ALTER VIEW old_view_name RENAME TO new_view_name;
```

### 2.2. Удаление представления

- Для удаления представления используется команда `DROP VIEW`:

```sql
DROP VIEW [IF EXISTS] view_name;
```

## 3. Модификация данных через представления

### 3.1. Ограничения на модификацию данных

- **Только одна таблица в `FROM`**: Если представление основано на нескольких таблицах (с использованием JOIN), модификация данных через такое представление невозможна.

- **Ограниченные SQL-конструкции**:
  - **Нельзя использовать**:
    - `DISTINCT`
    - `GROUP BY`
    - `HAVING`
    - `UNION`, `INTERSECT`, `EXCEPT`
    - `LIMIT`
  - **Ограничения на функции**:
    - Нельзя использовать оконные функции (например, `ROW_NUMBER`, `RANK`).
    - Нельзя использовать агрегатные функции (`MIN`, `MAX`, `SUM`, `COUNT`, `AVG`).

- **WHERE не под запретом**: Можно использовать блок `WHERE`, но условия должны соответствовать правилам однозначного обновления строк.

### 3.2. Модификация через `INSTEAD OF` триггеры

- Чтобы обойти ограничения на модификацию данных через представления, можно использовать `INSTEAD OF` триггеры:

```sql
CREATE TRIGGER trigger_name
INSTEAD OF INSERT OR UPDATE OR DELETE ON view_name
FOR EACH ROW EXECUTE FUNCTION trigger_function();
```

## 4. Опция `CHECK` в представлениях

### 4.1. Опция `CHECK OPTION`

- `CHECK OPTION` используется для ограничения изменений, которые нарушают условия выборки представления.
- Если представление создано с этой опцией, любые попытки вставки или обновления данных, которые приводят к нарушению условий `SELECT` в представлении, будут отклонены.

```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition
WITH CHECK OPTION;
```

### 4.2. Примеры использования `CHECK OPTION`

- Если представление должно показывать только сотрудников с зарплатой выше 5000, и данное представление создано с `CHECK OPTION`, то нельзя будет вставить или обновить запись так, чтобы зарплата была ниже 5000:

```sql
CREATE VIEW high_salary_employees AS
SELECT name, salary
FROM employees
WHERE salary > 5000
WITH CHECK OPTION;
```

## 5. Заключение

Представления в PostgreSQL предоставляют мощный инструмент для создания виртуальных таблиц, но они имеют ряд ограничений на их изменение и модификацию данных через них. Эти ограничения существуют для обеспечения целостности данных и однозначности операций. Однако, с помощью триггеров и опции `CHECK OPTION`, можно значительно расширить функциональность представлений.

---
