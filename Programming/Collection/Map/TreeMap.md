---
создал заметку: 2024-07-17
---
Элементами [[Programming/Collection/Map/Map|TreeMар]] являются пары ключ/значение.
В TreeMар элементы хранятся в ==отсортированном== по
возрастанию порядке. Отсортированы они естественно по ключу.

В основе TreeMар лежит [[красно-чёрное дерево]]. Это позволяет
методам работать быстро, но не быстрее, чем методы

==TreeMap может хранить одинаковые значения. ==
==TreeMap не может хранить одинаковые ключи==

## Методы :

##### put();
С помощью метода put(); мы можем вставлять Entry в TreeMap

##### get();
Можем получать какой то элемент по ключу treeMap.get(Object key) -> Value of this key

##### remove();
Удаляет объект по ключу

##### descendingMap();
С помощью этого метода, мы можем развернуть TreeMap в обратную сторону. Основываясь на ключах (keys);

##### TailMap();
Основная задача TreeMap это нахождение каких то ренжей (Range - диапазонов).  

Например нужно будет получить элементы у которых ключ больше определенного значения 
```java
Map<Double, Student> treeMap = new TreeMap<>();

System.out.print(treeMap.tailMap(7.5));

//Будет выведенны студенты у которых значение ключа больше заданного в параметре "tailMap";
```


##### HeadMap();
В этом методе наоборот мы получим значения которые больше заданного параметра "HeadMap"

```java
Map<Double, Student> treeMap = new TreeMap<>();

System.out.print(treeMap.headMap(7.5));

//Будет выведенны студенты у которых значение ключа меньше заданного в параметре "tailMap";
```

##### LastEntry();
С помощью этого метода мы можем вывести элемент нашего TreeMap который находиться в самом ==конце==
```java
Map<Double, Student> treeMap = new TreeMap<>();

System.out.print(treeMap.lastEntry(7.5));

// Мы выведем последнию пару (Entry) которая есть в нашем TreeMap
```

##### FirstEntry();
С помощью этого метода мы можем вывести элемент нашего TreeMap который находиться в самом ==начале==
```java
Map<Double, Student> treeMap = new TreeMap<>();

System.out.print(treeMap.firstEntry(7.5));

// Мы выведем последнию пару (Entry) которая есть в нашем TreeMap
```


## Comparable в TreeMap

В качестве ключа мы не можем использовать класс который не имплементирует интерфейс Comparable. - Почему? 

TreeMap хранит элементы в отсортированном порядке, за основу беря ключи.
Если же мы в качестве ключа подадим класс который TreeMap не сможет отсортировать то будет выброшен exсeption: 
```java
ClassCastExсeption: Student cannot be cast to class java.land.Comparable 
```

Так же можно создать отдельный компаратор прямо в параметре конструктора TreeMap.
Выглядеть это будет вот так: 
```java 
Map<Student, Double> treeMap = new TreeMap<>(new Comparator<Student>() {
		Override
		public int compare(Student ol, Student o2) {
		return 0;
	}
});
```


## Equals & HashCode

```java
Student st6 = new Student(name:"Sasha", surname: "Kapustin");
Student st7 = new Student(name:"Elena",surname: "Sidorova");

treeMap.put(st6, 8.2);
treeMap.put(st7, 7.9);

Student st8 = new Student(name:"Elena",surname: "Sidorova");


```

Если мы уберем нашу реализацию метода equals & Hash.
И проверим, если такой ключ в элементах нашего TreeMap?  
```java 
System.out.print(treeMap.containsKey(st8))
```
(Напомню что по методу equals сейчас они не равны, так как мы его не переопределили и эти объекты ссылаются на разные участи в памяти)

Так вот как мы помним это действие в HashMap выдало бы нам ==false==, потому что объекты в HashMap проверяются методом equals & HashCode. 

Но при использовании ==TreeMap== нет необходимости  переопределять методы ==equals & HashCode== для объекта ключа. Потому что все методы (добавление, удаление, поиск и тд) осуществляются при помощи метода ==compareTo();==


==НО!! Это правильно не относиться к значениям!!==


Например при работе метода: 
```java 
System.out.print(treeMap.containsValue(st8))
```
(проверяет, есть ли такое значение в элементах нашего TreeMap)

При роботе этого метода equals будет использовать, хотя HashCode задействован не будет! 

## ==Хорошим тоном! В независимости от обстоятельств всегда переопределять эти методы! Equals & HashCode==


## Немного о деревьях
В основе TreeMар лежит [[красно-чёрное дерево]] (RedBlackTree) - это один из видов сомобалансирующихся двоичных деревьев поиска.

Углубляться не будем в красно-черные деревья просто рассмотрим какие вообще бывают деревья для начального понимания

Дерево может выглядеть как то вот так, если дерево содержит целочисленные значения:
![[FirstTree.png]]

Немного ***терминологии***: 
Число ==13== называется **==корнем==** дерева
Все элементы называются **==вершинами==**
Все вершины которые не имеют потомков называются **==листьями==**


Так же есть ==двоичные деревья:==
двоичными деревьями называют деревья у которых 2 потомка: 

![[BineryTree.png]]

Так же есть понятие балансировки в деревьях.
Пример не сбалансированного дерева: 

![[Non-BalancedTree.png]]
Поиск по такому дереву будет выполняться очень долго

Красно черное дерево является не только двоичными но и автобалансирующимся 
![[BineryTree.png]]

На каком то этапе дерево понимает что все идет в одну сторону и нужно перегрупероваться (*как я понял* будет взято какое то среднее значение и от него будет создаться ветвление в лево и право) Использование методов (get(), put(), remove()) в TreeMap
выполняется за время O(log n); Медленнее чем у HashMap но быстрее обычного поиска. 


В завершении нужно помнить что ==TreeMap== не является синхронизированной коллекцией. По этому если имеется много потоков работающих с данной коллекцией нужно в ==ручную синхронизировать==