---
создал заметку: 2024-07-15
---
![[MapInterface.png]]

Элементами [[Programming/Collection/Map/Map|HashMар]] являются пары ключ/значение.
Hashmap не запоминает порядок добавления элементов.
Его методы работают очень быстро.


Ключи должны быть **уникальными**.
Значения могут **повторяться**.

Ключ может быть ==null== 
Значение может быть ==null==

	Если мы попытаемся вставить элемент с ключем который уже есть, то ключ останется   прежним а вот значение перезапишется!

```Java
map1.put(1000, "Ovel Ivanov");
map1.put(1000, "Kiril Segeevich");

//В итоге останется вот такая пара: 
// 1000, "Kiril Segeevich"
//Ключь станется а вот значение перезапишется
```

### Интересные методы HashMap

### 1) putIfAbsent()
Проверяет ключи элементов, если такого ключа еще нет, тогда добавит в HashMap, если же есть то элемент добавлен не будет
### 2)get()
В методе get мы указываем ключ. И если такой ключ существует по мы получим значение.
```Java
System.out.print(map1.get(1000));
// Если такой ключ есть может вывестись например: 
// Kiril Segeevich
// Если же такого ключа нет, будет выведен null
```
### 3)remove()
Удаляет из HashMap элемент
### 4)containsValue() -- > boolean 
Вернет ==true== если **значение** есть, и ==false== если его нет 
### 5)containsKey() --> boolean 
Вернет ==true== если **ключ** есть, и ==false== если его нет 
### 6)keySet()
Это метод возвращает множество ключей
### 7)values()
Это метод возвращает множество значений 




HashMap в Java работает по принципам хэширования.
В Java хэширование это преобразование любого объекта в число (int)
```java 
public int hashCode(){
	
}
```


Все объекты в Java наследуют стандартную реализацию hash функции. Эта функция возвращает число полученное путем конвертации внутреннего адреса объекта. Что ведет к созданию уникального кода для каждого объекта.

![[NodeNestedClassInHashMap.png]]


![[descriptionOfHashMap.png]]

Подробный разбор как работает HashMap
---

![[HashMapDrow1.png]]
При создании HashMap, создается массив из 16 элементов.
Такой массив называется table.


Каждый элемент массива это представляет собой SingleLinkedList, 
еще элементами массива называют корзинами (bucket) именно в них и будут храниться пары(ключ, значение)

Рассмотрим как работает метод ==put==

В первую очередь идет проверка ==**ключа**== на ==null==, если наш ключ равен null то тогда он поместиться в 0 индекс массива 


в нашем случает ключ не null. Тогда находиться hashCode для ключа: 
![[HashMapDrow2.png]]
В примере для ключа (st1) -> hashCode = 315. 
На основе ключа, используя алгоритм, вычисляется индекс по которому будет расположен данный элемент.

Это означает что если мы в следующий добавим элемент с hashCode = 315 то он будет помещен в тот же элемент массива. Потому что если hashCode одинаковый то и index тоже будет одинаковый (такое поведение когда несколько объектов находятся в одном bucket называется ==**коллизией**==)




![[HashMapDrow4.png]]
В данном примере на индекс 3 был добавлен объект класса Node

![[NodeNestedClassInHashMap.png]]

Который хранит в себе 4 поля: 
hash = 315;
key = st1;
value = 7.5;
next (ссылка на следующий элемент) = null
	в данном случае это первый элемент в bucket и после него никакого элемента нет, поэтому ссылка равна ==null==

![[HashMapDrow5.png]]
Рассмотрим другой пример
Мы добавили в hashMap (st3, 9.2) -> hashCode = 562;
И при вычислении индекса мы снова получили ==7==. То есть индекс  bucket в котором уже есть элемент.

Что в этом случае происходит? 
В первую очередь происходит проверка hashCode: 562 != 185;
Значит by deffoult их ключи не одинаковы, их equal не может быть true( метод equals даже не проверяется, hashCode потому что разные и нет смысла в проверке equals )

Что будет происходить потом? 
Будет создаваться новая нода (Node) и будет добавляться в конец нашего LinkedList. Предыдущая нада(Node) уберет из поля Next = null и поместит туда ссылку на следующий объект.



![[HashMapDrow7.png]]

Еще один пример: 
добавим еще один элемент: 
map.put(st4, 7.1) -> hashCode = 185;
Здесь мы столкнулись с коллизией. То есть hashCode st2 и st 4 совпали ( 185 - 185 );

Если hashCode совпали, то объекты проверяются на равенство методом equals.
В нашем случае метод equals показал false ( то есть объекты на равны )
Проверка идет дальше, 185 != 562 , значит на equals можно не проверять, объекты и так не равны. 
Получается мы добавляем новый элемент в конец нашего списка. 



![[HashMapDrow7.png]]
Еще один не большой пример: 
Давайте добавим еще один элемент:
```java
map.put(st5, 3.4);
```
И давай те предположим что метод equals вернет true на объектах (st5 и st1). То есть они равны. 

Что происходит в этом случае?
Естественно что если объекты одинаковые, то и hashCode у них будет одинаковый. 

( 315 - 315)

Затем снова вычисляется индекс позиции, он очевидно будет совпадать и равен = 3;

Ну а затем происходит проверка этого bucket. 
Если там есть элемент, то происходит проверка равны ли их hashCode?  - Да равны. 
Равны ли они по equals? - Да равны.

Получается что и по hashCode и по equals они равны, и происходит замена значений. 

HashCode был одинаковый так что он не меняется 
st1 заменятся на st5;
7.5 замениться на 3.4;
null также останется 





![[HashMapDrow8.png]]
Рассмотрим несколько примеров, c методом ==**get**==

Например мы создали новый объект ==st6==
В котором значение полей такие же как и в ==st3==
То есть эти объекты равны по методу equals. 
Что будет происходить? 
```java 
map.get(st6);
```

Находиться hashCode для ключа ==st6==, и он равен 562 потому что он должен быть таким же как и st3 

Находиться где - бы содержался такой элемент если бы он был в нашем hashMap, то есть находиться index = 7;

У нас в нашем идексе 7 есть несколько элементов. 
Выполняется проверка на hashCode, если не равно то переходит к следующему элементу. 

Если HashCode совпали, выполняется проверка на equals, и если equals вернет true. 

То метод get вернет значение: этого элемента: 

В нашем случае он вернет:==9.2==  




Тонкости работы с HashMap
=
---
При создании HashMар мы можем задать 2 параметра,
которые очень влияют на производительность:
•==Initial сарacity== - начальный размер массива;
•==Load factor== - коэффициент того, насколько массивна
должен быть заполнен, после чего его размер будет
увеличен вдвое.

![[HashMapLoadFactor.png]]

Вставка и поиск элемента: O(1) - константное время 

