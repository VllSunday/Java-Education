---
создал заметку: 2024-07-27
---
![[JAVA SE. Лекция 14.pdf]]

### Потоки данных Stream API 

Потоки данных обеспечивают представление данных, позволяющее выполнять вычисления на более высоком концептуальном уровне, чем коллекции.

С помощью потока данных можно указать, что и как именно требуется сделать с данными.

Средствами Stream API можно оптимизировать вычисления, используя, допустим, несколько потоков исполнения для расчета сумм, подсчета и объединения результатов.

### Виды потоков: 
![[StreamDifferent.png]]
#### `Потоки данных действуют по принципу “что, а не как делать”`
Пример: 
```java
byte[] bytes = Files.readAllBytes(Paths.get(PATH_TO_DEMO_TXT_FILE));

        //Преобразуем текст из файла в символьную строку
        String contents = new String(bytes, StandardCharsets.UTF_8);

        //Выделяем из всего файла - список слов
        String[] words = contents.split("\\PL+");

        //Выполняем подсчет количества слов
        int count = 0;
        for (String w : words) {
            if (w.length() > 12) {//считаем слово длинным, если length > 12
                count++;
            }
        }
```
Мы хотим сделать подсчет длинных слов. Используя цикл мы имеем строгий порядок, то есть идем слово за словом. То есть у нас точно указан порядок организации вычислений, и в данном случае у нас нет возможностей для оптимизаций.

##### **Основные отличия потока от коллекции**:

###### 1) Поток данных не сохраняет свои элементы. Они могут храниться в основной коллекции или формироваться по требованию.
###### 2) Потоковые операции не изменяют источник данных. 
   Например: мы используем метод filter. Он не удаляет элементы из нового потока данных, он создает нам новый поток. В котором они отсутствуют. Например у нас был потом со словами(String) и мы получили новый поток с одним словом(пример). Мы не получали поток со всеми словами и не делали delit из этого потока. Мы получили новый поток с одним словом, где отсутствовали короткие слова 
###### 3) Потоковые операции выполняются по требованию, когда это возможно. -Что это значит? 

Это значит: они не будут выполняться до тех пор пока не потребуют их результат. 

Например: Если требуется посчитать только 5 длинных слов, вместо всех слов, метод filter() прекратит фильтрацию после 5-го
совпадения. По этой же причине потоки данных могут быть бесконечными


### ==Конвейер операций организуется в следующие три стадии:==
1) Создание потока данных
2) Указание промежуточных операция для преобразования исходного потока данных в другие потоки, возможно, в несколько этапов. 
3) Выполнение терминальной операции для получения результата.
![[srteam stage.jpeg]]

То есть есть 3 основных этапа. 
- За создание потока отвечает команда: stream() , или paralelStream()
- Промежуточными операторами могут быть: filter(), map(),reduce()
- Терминальный оператор (операция сведения)
### Ленивость потоков (Streams)

Ленивость потоков означает, что промежуточные операции (такие как `filter`, `map` и т.д.) не выполняются сразу, когда они вызываются. Вместо этого они накапливаются и откладываются до тех пор, пока не будет вызвана терминальная операция (например, `collect`, `count` и т.д.). Только тогда все накопленные промежуточные операции выполняются последовательно на элементах потока.


### Как создаются потоки данных в Java

Создание потока данных 
1) Пустой стрим: Stream.empty()
2) Стрим из List: list.stream() 
3) Стрим из Map: map.entrySet().stream() 
4) Стрим из массива: Arrays.stream(array) 5) Стрим из указанных элементов: Stream.of(“a”, “b”, “c”)

Любую коллекцию мы можешь преобразовать в поток данных методом stream()




