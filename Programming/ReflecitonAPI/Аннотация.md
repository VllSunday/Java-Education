---
создал заметку: 2024-08-31
---
Аннотация в Java — это специальный тип комментария, который предоставляет метаданные для классов, методов, полей или других элементов программы. Аннотации не влияют напрямую на логику работы программы, но могут использоваться для предоставления дополнительной информации, которую могут обрабатывать компилятор, инструменты сборки или фреймворки во время компиляции или выполнения программы.

### Основные характеристики аннотаций:

1. **Метаданные**: Аннотации содержат метаданные о коде. Они могут использоваться для конфигурирования поведения программ или предоставления информации инструментам разработки.

2. **Не влияют на исполнение**: Аннотации не меняют логики исполнения программы, но могут использоваться для генерации кода, валидации и других задач.

3. **Обработка**: Аннотации могут обрабатываться:
   - **Компилятором**: Например, аннотация `@Override` проверяет, что метод действительно переопределяет метод из суперкласса.
   - **В процессе выполнения (runtime)**: Например, с помощью Reflection API можно узнать, какие аннотации применены к элементам программы, и использовать их для выполнения соответствующих действий.

### Примеры стандартных аннотаций

1. **`@Override`**: Указывает, что метод переопределяет метод суперкласса. Используется для проверки корректности переопределения.

   ```java
   @Override
   public String toString() {
       return "MyClass";
   }
   ```

2. **`@Deprecated`**: Отмечает метод или класс как устаревший. Использование такого элемента в коде приведет к предупреждению компилятора.

   ```java
   @Deprecated
   public void oldMethod() {
       // устаревший метод
   }
   ```

3. **`@SuppressWarnings`**: Инструктирует компилятор игнорировать определенные предупреждения.

   ```java
   @SuppressWarnings("unchecked")
   public void myMethod() {
       // код, который вызывает предупреждения компилятора
   }
   ```

4. **`@Retention`**: Определяет, как долго аннотация сохраняется. Может принимать следующие значения:
   - `SOURCE`: аннотация доступна только на этапе компиляции и не включается в байт-код.
   - `CLASS`: аннотация сохраняется в байт-коде, но недоступна во время выполнения.
   - `RUNTIME`: аннотация сохраняется в байт-коде и доступна во время выполнения через Reflection.

   ```java
   @Retention(RetentionPolicy.RUNTIME)
   public @interface MyAnnotation {
       String value();
   }
   ```

5. **`@Target`**: Определяет, к каким элементам программы может быть применена аннотация (класс, метод, поле и т. д.).

   ```java
   @Target(ElementType.METHOD)
   public @interface MyMethodAnnotation {
   }
   ```

### Создание собственной аннотации

Вы можете создавать свои аннотации в Java:

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)  // аннотация будет доступна в runtime
@Target(ElementType.METHOD)  // аннотация может применяться только к методам
public @interface MyAnnotation {
    String value();  // параметр аннотации
}
```

Использование созданной аннотации:

```java
public class MyClass {

    @MyAnnotation("Example")
    public void myMethod() {
        System.out.println("This is my method.");
    }
}
```

### Заключение

Аннотации в Java — мощный инструмент для добавления метаданных в ваш код, который может использоваться для документирования, валидации и управления поведением программ во время компиляции и выполнения. Они широко используются в фреймворках и библиотеках, таких как Spring, JUnit и Hibernate, для упрощения конфигурации и управления кодом.

---
### Основная информация:
### @Target

Аннотация `@Target` используется для указания, к каким элементам программы может быть применена ваша аннотация. Это важно для того, чтобы ограничить применение аннотации только к тем элементам, для которых она предназначена.

`@Target` принимает массив значений типа `ElementType`, который определяет, где может использоваться аннотация. Вот основные элементы, которые вы можете указать:

- **`ElementType.TYPE`**: Аннотация может применяться к классу, интерфейсу или перечислению (`enum`).
  
  ```java
  @Target(ElementType.TYPE)
  public @interface MyTypeAnnotation {
  }
  
  @MyTypeAnnotation
  public class MyClass {
  }
  ```

- **`ElementType.FIELD`**: Аннотация может применяться к полю класса (переменной экземпляра).
  
  ```java
  @Target(ElementType.FIELD)
  public @interface MyFieldAnnotation {
  }
  
  public class MyClass {
      @MyFieldAnnotation
      private String name;
  }
  ```

- **`ElementType.METHOD`**: Аннотация может применяться к методу.
  
  ```java
  @Target(ElementType.METHOD)
  public @interface MyMethodAnnotation {
  }
  
  public class MyClass {
      @MyMethodAnnotation
      public void myMethod() {
      }
  }
  ```

- **`ElementType.PARAMETER`**: Аннотация может применяться к параметру метода.
  
  ```java
  @Target(ElementType.PARAMETER)
  public @interface MyParameterAnnotation {
  }
  
  public class MyClass {
      public void myMethod(@MyParameterAnnotation String param) {
      }
  }
  ```

- **`ElementType.CONSTRUCTOR`**: Аннотация может применяться к конструктору.
  
  ```java
  @Target(ElementType.CONSTRUCTOR)
  public @interface MyConstructorAnnotation {
  }
  
  public class MyClass {
      @MyConstructorAnnotation
      public MyClass() {
      }
  }
  ```

- **`ElementType.LOCAL_VARIABLE`**: Аннотация может применяться к локальной переменной.
  
  ```java
  @Target(ElementType.LOCAL_VARIABLE)
  public @interface MyLocalVariableAnnotation {
  }
  
  public class MyClass {
      public void myMethod() {
          @MyLocalVariableAnnotation
          String localVar = "Hello";
      }
  }
  ```

- **`ElementType.ANNOTATION_TYPE`**: Аннотация может применяться к другой аннотации, то есть ваша аннотация становится мета-аннотацией.
  
  ```java
  @Target(ElementType.ANNOTATION_TYPE)
  public @interface MyMetaAnnotation {
  }
  
  @MyMetaAnnotation
  public @interface AnotherAnnotation {
  }
  ```

- **`ElementType.PACKAGE`**: Аннотация может применяться к пакету.
  
  ```java
  @Target(ElementType.PACKAGE)
  public @interface MyPackageAnnotation {
  }
  ```

- **`ElementType.TYPE_USE`**: Аннотация может применяться практически к любому использованию типа, включая параметры типов и возвращаемые значения методов.
  
  ```java
  @Target(ElementType.TYPE_USE)
  public @interface MyTypeUseAnnotation {
  }
  
  public class MyClass {
      public @MyTypeUseAnnotation String myMethod() {
          return "Hello";
      }
  }
  ```

### @Retention и @RetentionPolicy

Аннотация `@Retention` определяет, насколько долго аннотация будет сохраняться и когда она будет доступна. `RetentionPolicy` определяет различные этапы жизненного цикла программы, когда аннотация может быть доступна:

- **`RetentionPolicy.SOURCE`**: Аннотация доступна только на этапе компиляции и не включается в байт-код. Такие аннотации используются для предоставления информации компилятору или инструментам разработки. Например, `@Override` — это аннотация с `RetentionPolicy.SOURCE`.

  ```java
  @Retention(RetentionPolicy.SOURCE)
  public @interface MySourceAnnotation {
  }
  ```

- **`RetentionPolicy.CLASS`**: Аннотация сохраняется в байт-коде, но недоступна во время выполнения. Это значение используется по умолчанию, если не указано другое.

  ```java
  @Retention(RetentionPolicy.CLASS)
  public @interface MyClassAnnotation {
  }
  ```

- **`RetentionPolicy.RUNTIME`**: Аннотация сохраняется в байт-коде и доступна во время выполнения через Reflection API. Такие аннотации часто используются в фреймворках, например, для DI (Dependency Injection) или ORM (Object-Relational Mapping).

  ```java
  @Retention(RetentionPolicy.RUNTIME)
  public @interface MyRuntimeAnnotation {
  }
  ```

### Кастомные аннотации и их использование

Кастомные аннотации создаются, когда вам нужно добавить собственные метаданные к вашему коду. Это особенно полезно при создании собственных фреймворков, библиотек или для упрощения повторяющихся задач.

#### Пример использования кастомной аннотации

Допустим, вам нужно вести логирование вызовов определённых методов в вашем приложении. Вместо того, чтобы вручную добавлять код логирования в каждый метод, вы можете создать кастомную аннотацию и использовать её вместе с аспектно-ориентированным программированием (AOP) или Reflection API.

1. **Создание аннотации**:

   ```java
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;

   @Retention(RetentionPolicy.RUNTIME)
   @Target(ElementType.METHOD)
   public @interface Loggable {
   }
   ```

2. **Использование аннотации**:

   ```java
   public class MyService {

       @Loggable
       public void performAction() {
           System.out.println("Action performed!");
       }
   }
   ```

3. **Обработка аннотации с помощью Reflection API**:

   ```java
   import java.lang.reflect.Method;

   public class LogProcessor {

       public static void processLogs(Object obj) throws Exception {
           Class<?> clazz = obj.getClass();
           for (Method method : clazz.getDeclaredMethods()) {
               if (method.isAnnotationPresent(Loggable.class)) {
                   System.out.println("Logging: " + method.getName());
                   method.invoke(obj);
               }
           }
       }

       public static void main(String[] args) throws Exception {
           MyService service = new MyService();
           processLogs(service);
       }
   }
   ```

   В этом примере, когда вы вызываете `processLogs(service)`, метод `performAction` будет автоматически логироваться благодаря аннотации `@Loggable`.

### Заключение

Аннотации `@Target` и `@Retention` позволяют гибко настраивать применение и жизненный цикл аннотаций в Java. Кастомные аннотации предоставляют мощный способ добавить метаданные и инструменты в ваш код, облегчая разработку и поддержание больших систем. Они широко используются в фреймворках и библиотеках для автоматизации задач, улучшения читаемости кода и повышения уровня абстракции.

---
### Итог

Мы можем воспользоваться доп мета информацией, для нашего класса(это аннотации) для своих нужд.

Мы можем использовать их как угодно. Как мы захотим, давая аннотации определенные свойства(они же методы).

Так же мы можем 2 два параметра. 

@Таргет - то где мы можем применить нашу анатацию 
@Retention , а точнее @RetantionPolicy - в какой момент нашей программы мы можем получить доступ к нашей аннотации 

CLASS по умолчанию
SOURE - после компиляции у нес не будет этой аннотации(например аннотация Override)
RUNTIME - самая популярная RetantionPolicy - мы сможем иметь доступ к нем во время выполнения.

