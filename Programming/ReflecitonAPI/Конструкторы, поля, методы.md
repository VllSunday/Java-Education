---
создал заметку: 2024-08-31
---
Конечно! Давайте подробно разберем работу с методами в Reflection API.

---

## Методы

### Получение методов

В Reflection API можно получить метод класса несколькими способами:

1. **`getDeclaredMethod(String name, Class<?>... parameterTypes)`**  
   Позволяет получить метод класса, включая методы с любыми модификаторами доступа (private, protected, public). Этот метод возвращает объект `Method`.

   ```java
   Method declaredMethod = User.class.getDeclaredMethod("setName", String.class);
   ```

2. **`getMethod(String name, Class<?>... parameterTypes)`**  
   Этот метод аналогичен `getDeclaredMethod`, но он возвращает только публичные методы.

   ```java
   Method method = User.class.getMethod("getName");
   ```

### Вызов метода

После того как вы получили объект `Method`, вы можете вызвать этот метод на определенном объекте:

```java
Method declaredMethod = User.class.getDeclaredMethod("setName", String.class);

// Вызов метода setName на объекте user
declaredMethod.invoke(user, "Zhendos");
```

### Обработка исключений

Вызов методов через Reflection API может генерировать несколько исключений:

- **`NoSuchMethodException`**  
  Выбрасывается, если метод с указанным именем и параметрами не найден.

- **`IllegalAccessException`**  
  Выбрасывается, если к методу нет доступа из-за его модификатора (например, private). Можно обойти с помощью `method.setAccessible(true)`.

- **`InvocationTargetException`**  
  Выбрасывается, если метод, вызванный через `invoke`, выбрасывает исключение.

### Пример работы с методами

Рассмотрим полный пример, который включает получение метода, его вызов и обработку исключений:

```java
private static void testMethods(User user) {
    try {
        // Получение метода setName, принимающего строковый параметр
        Method declaredMethod = User.class.getDeclaredMethod("setName", String.class);

        // Делаем метод доступным для вызова, если он private
        declaredMethod.setAccessible(true);

        // Вызов метода setName на объекте user с аргументом "Zhendos"
        declaredMethod.invoke(user, "Zhendos");

        // Вывод имени пользователя после вызова метода
        System.out.println(user.getName());
        
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        e.printStackTrace();
    }
}
```

### Получение всех методов класса

Если нужно получить все методы класса, включая унаследованные и приватные, можно использовать:

- **`getDeclaredMethods()`**  
  Возвращает массив всех методов, объявленных в классе, включая приватные.

   ```java
   Method[] declaredMethods = User.class.getDeclaredMethods();
   ```

- **`getMethods()`**  
  Возвращает массив всех публичных методов класса, включая унаследованные.

   ```java
   Method[] methods = User.class.getMethods();
   ```

### Пример использования всех методов

Рассмотрим, как можно получить и вывести информацию обо всех методах класса `User`:

```java
private static void testAllMethods(User user) {
    // Получаем все методы, включая приватные
    Method[] declaredMethods = User.class.getDeclaredMethods();

    for (Method method : declaredMethods) {
        // Выводим имя метода
        System.out.println("Method Name: " + method.getName());

        // Выводим параметры метода
        Class<?>[] parameterTypes = method.getParameterTypes();
        for (Class<?> paramType : parameterTypes) {
            System.out.println("Parameter Type: " + paramType.getName());
        }

        // Выводим возвращаемый тип метода
        System.out.println("Return Type: " + method.getReturnType().getName());

        System.out.println("-------------------");
    }
}
```

### Итог

Reflection API позволяет гибко работать с методами классов, предоставляя возможность динамически вызывать их, получать информацию о параметрах и возвращаемых значениях, а также обходить модификаторы доступа. Это делает Reflection мощным инструментом для выполнения операций, которые иначе были бы невозможны или крайне сложны.

---
