---
создал заметку: 2024-09-01
---
Что бы не нарушать типо безопасность в Java. Мы не можем например: 


```java
ArrayList<Citrus> сitruses = new ArrayList<>();

ArrayList<Orange> oranges = new ArrayList<>();
ciruses = oragnes // НЕЛЬЗЯ
```

Потому что любой класс(интерфейс) объявленный как обобщенный является инвариантным. То есть может принемать и работать только с одним типом данных.

Но что делать если например у меня есть метод: 


```java
private static int totalWeight(ArrayList<Orange> oranges) {  
    int weight = 0;  
    for (int i = 0; i < oranges.size(); i++) {  
        weight += oranges.get(i).weight;  
    }  
    return weight;  
}
```

Мы уже поняли что мы нем можем работать в этом методе с другими типами, только с Citrus можно. 
Но приложение не сломается если, например, мы сможем считать другие цитрусовые а не только апельсины. 

По этому в я Java есть синтаксис который может позволить сделать это: 


```java
private static int totalWeight(ArrayList<? extends Citrus> oranges)
```
При такой записи, мы можем передавать любые List-ы которые наследуют Citrus(ну и сам Citrus тоже)


```java
ArrayList<? extends Citrus> oranges
```
Вот эту запись можно читать как: "Что то наследующее Citrus"

Но у такой записи есть свои ограничения: 

---
# Ковариантность

### Операция =
 Frute frute  = oranges.get(i);
Приравнивание можно делать только: List`<Type>` и List наследников Type

### Операция get

Только Type и предки Type

### Операция add 
Ничего
 -  Потому что Java не знает какой тип теперь использовать и для сохранения TypeSave(типо безопасности) мы не можем добавлять вообще ничего
---
# Контравариантность

### Операция = 
Только List`<Type>`и List предков Type

### Операция get
Только Object

**Объяснение:**

- Компилятор не знает точного типа элементов, которые могут находиться в `List<? super Type>`, потому что это может быть `Type`, `ParentType` или любой другой предок `Type`.
- Единственное, что гарантируется, это то, что все элементы коллекции будут как минимум объектами, поэтому возвращаемое значение будет типа `Object`.