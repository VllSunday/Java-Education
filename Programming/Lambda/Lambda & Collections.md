---
создал заметку: 2024-07-24
---
Есть некоторые методы, который пришли из других функциональных языков программирования, таких как Haskel.
Эти методы позволяют очень быстро и кратно проводить операции над массивами и коллекциями.


## Специальный метод `MAP();`

Например у нас есть коллекция в которой есть целые числа. И мы хотим каждое целое число умножить на 2 и получить новую коллекцию. 

```java
public static void main(String[] args) {  
    int[] array = new int[10];  
    List<Integer> list = new ArrayList<>();  
  
    fillArray(array);  
    fillList(list);  
  
    System.out.println(Arrays.toString(array));  
    System.out.println(list + "\n");  
  
    for (int i = 0; i < 10; i++) {  
        array[i] = array[i] * 2;  
        list.set(i, list.get(i) * 2);  
    }  
  
    System.out.println(Arrays.toString(array));  
    System.out.println(list);  
}  
  
private static void fillArray(int[] array) {  
    for (int i = 0; i < 10; i++) {  
        array[i] = i + 1;  
    }  
}  
  
private static void fillList(List<Integer> list) {  
    for (int i = 0; i < 10; i++) {  
        list.add(i + 1);  
    }  
}
```

В этом примере, у нас есть массив и List. 
Есть 2 метода которые заполняют эти коллекции от 1 до 10

Также мы сделали цикл который проходит по каждому элементу коллекции и обновляет значение путем умножения на 2.

### Теперь как мы это можем сделать использую `Lambda`

Как мы будем это делать: 
```java
Для массива

array = Arrays.stream(array).map(a -> a * 2).toArray();

Для списка
list = list.stream().map(a -> a * 2).collect(Collectors.toList());
```

Разберем этот код: 
Для массива: 
steam() - это статический метод в классе Arrays, который на вход принимает массив. А на выходе получается поток данных: 

```java
public static IntStream stream(int[] array) {  
    return stream(array, 0, array.length);  
}
```
Вот как реализован этот поток в Java

Этот поток не имеет ни какого отношения к многопоточности.

Как это легче запомнить: 
Представить что Лямбда не может на прямую использовать массив или список , и нам нужно превратить наши коллекции в другую сущность, в данном случаи в целочисленный поток. Уже с потоком мы можем делать какие то преобразования.


Давайте двигаться дальше, теперь мы вызовем метод map()
```java
Arrays.stream(array).map()
```
`map` как раз тот самый метод который пришел в Java из других функциональных языков программирования, и позволяет легко изменять какие то наборы данных.

`map` берет каждый элемент из набора данных и сопоставляет ему новый элемент. Сопоставление как раз мы описываем с помощью лямбда выражения.






## Специальный метод `filter();`


Следующий метод который оперирует над наборами данных, это метод `filter();`. Исходя из названия этот метод фильтрует наши данные.


Например если мне нужно какое то подмножество из общего множества то можно применить метод filter(); что бы отфильтровать только нужные вам данные.

Пример использования: 
Например из значений: 
```java
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

мы хотим оставить только те который делятся без остатка на 2.

Вот как это можно сделать. Для начала давайте запустим метод filter(); на массиве

```java
array.stream(array).filter(a -> a % 2 == 0).toArray();
```

И в качестве аргумента передадим лямбда выражение, в котором мы опишем нашу логику.

У нас также filter, проходится по каждому элементу массива, и проверяет соответствует элемент критерию. Критерий как раз мы и описываем в теле лямбда выражения: 
```java 
-> a % 2 == 0
```
(что идет после знака `->`) это тело лямбда выражения.

тело лямбда выражения в методе ==filter();== должно возвращать boolean переменную.
Возвращает true - если элемент соответствует нашему критерию
Возвращает false - если не соответствует критерию 



## Специальный метод `forEach();`

Это очень простой метод, который просто может помочь быстро пройтись по каждому элементу в коллекции. 


```java
array.stream(array).forEach(a -> System.out.println());
```

То есть в этом коде, мы просто вывели каждый элемент массива на экран, проходя по массиву с помощью метода `forEach();`


Эту запись можно сделать еще проще: 
```java
array.stream(array).forEach(System.out::println);
```

Заметьте что мы использует ` :: ` что до этого не было в нашем коде.
Два двоеточия мы ставим потому что мы обращаемся в самому методу, и передаем на вход методу forEach даже не лямбду а просто указатель на метод.
И метод forEach понимает что у этого метода всего 1 аргумент, мы как раз не место этого аргумента передаем текущий аргумент в списке



## Специальный метод `reduce();`

`reduce ` переводится с английского как уменьшение.

И он действительно уменьшает массив(или любую другую коллекцию) до одного элемента

Это и есть задача reduce(); - у него есть набор каких то данных, и он сжимает его в какой то один элемент.



Например мы хотим взять лист элементов и хотим посчитать сумму всех элементов. В этом случае мы имеем набор элементов а на выходе имеем один элемент, получается мы как бы сжали лист элементов до 1 элемета 


Как это сделать? 
Для начала мы вызываем метод reduce(); например на массиве: 

```java 
array.stream(array).reduce()
```

Как он работает? 
Теперь у нас в лямбда будет 2 аргумента.
1 - й элемент называется "акамулятор" 
2 - й элемент называется "текущий элемент "

```java 
array.stream(array).reduce((acc, b) -> )
```

В чем суть акамулятора? Суда по названию он акумулирует данные, то есть наша переменная "acc" будет как временная переменная, переменная счетчик. 

Которая будет каждый раз обновляться.

А переменная "b" на каждой итерации внутреннего цикла в этом методе reduce(); она у нас равняется текущему элементу.

Ну и вот как это все будет выглядеть на практике: 

```java
int sum =array.stream(array).reduce((acc, b) -> acc + b).getAsInt();
```
Обратите внимает что для того что бы наш поток преобразовать в переменную int, нам нужно вызвать метод ( getAsInt );

Тоже самое только умножение с list: 
```java
int sum list.steam().ruduce((acc, b) -> acc * b).get();
```


Тонкости работы метода reduce();

указать значение акакулятора, можно вот так: 
```java
int sum = Arrays.stream(array2).reduce(0, (acc, b) -> acc + b);
```
Если мы не укажем начальное значение для акамулятора

То начнем итерацию со второго элемента: 

Например у нас есть: 
```java
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Если ничего не указывать, то мы начнем итерацию со второго элемента. То есть переменная b будет находиться сразу на 2
А переменная ==acc== будет на первом. 
И как будет происходить выполнение код? - Переменная ==acc==
хранит в себе значение 1, переменна ==b== хранит в себе 2, на первой итерации произойдет следующее, значение тела лямбда ==(acc + b)== будет присвоено  переменной ==acc==. На следующий итерации будет так же, переменная b будет смещена на 1 значение, и снова будет происходить тоже самое, будет ==(acc + b)== acc уже был равен 3-м поэтому, 3 + 3 = 6, и снова переменно acc будет присвоено ==6==


Но если мы укажем значение acc. Например 0.
То итерация будет проходить начиная с первого элемента. 
То есть acc будет хранить в себе 0, а b будет стоять на числе 1. 
После первой итерации, acc = 1; b - находиться на числе 2 и тд...



То есть мы можем задать начальную позицию в которой будет находиться acc (То есть какое в данном случае число он будет хранить в себе)



