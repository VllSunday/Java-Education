---
создал заметку: 2024-08-21
---
### Name
- getName()
- setName()
Эти методы связанны с именем потока. У каждого потока есть имя, с помощью которого мы можем его идентифицировать 

Если не указывать имя задаться дефолтное значение: ==Thread-n== где n просто число 

### Priority
- getPriority()
- setPriority()
Эти методы связанны с приоритетом потока. У каждого потока есть приоритет

Если не указывать приоритет задаться дефолтное значение: ==5== где 5 это значение от 1 до 10
Где 10 это максимальный приоритет. 

Но никакой гарантии нет, что потом с высшим приоритетом запуститься быстрее чем поток с более низким приоритетом. ==Гарантий нет==

![[Pasted image 20240821161104.png]]
Можно так же указать, константами


# Sleep
---
`Sleep` — это метод в классе `Thread`, который позволяет приостановить выполнение текущего потока на определённое количество времени. В это время поток «спит», и его выполнение временно приостанавливается. После завершения времени сна поток возобновляет свою работу.

#### Как работает `sleep`

Когда вызывается `Thread.sleep(milliseconds)`, текущий поток «засыпает» на указанный период времени. В это время поток ничего не делает, но не освобождает свои ресурсы и не переходит в состояние ожидания другого потока. После завершения времени сна поток просыпается и продолжает выполнение с той точки, на которой был остановлен.

```java
try {
    Thread.sleep(1000);  // Поток засыпает на 1 секунду (1000 миллисекунд)
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

#### Особенности и ограничения

1. **Поток не освобождает ресурсы:** Несмотря на то, что поток временно приостанавливается, он не освобождает захваченные ресурсы, такие как блокировки или память.

2. **Прерывание сна:** Поток может быть прерван во время сна с помощью метода `interrupt()`. Если поток прерван во время выполнения `sleep()`, выбрасывается исключение `InterruptedException`.

3. **Не гарантирует точного времени сна:** Время сна может варьироваться в зависимости от операционной системы и нагрузки на систему. Поток может проснуться немного раньше или позже указанного времени.

4. **Использование `sleep` для симуляции задержек:** Метод `sleep` часто используется для создания искусственных задержек, например, для симуляции временных задержек в процессах или для тестирования.

#### Пример использования

```java
class MyThread extends Thread {
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Работа потока: " + i);
            try {
                Thread.sleep(1000);  // Поток «спит» 1 секунду между итерациями
            } catch (InterruptedException e) {
                System.out.println("Поток был прерван");
            }
        }
    }
}

public class Example {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start();
    }
}
```

# Join
---
Метод `join()` используется для того, чтобы приостановить выполнение текущего потока до тех пор, пока другой поток не завершит своё выполнение. Это полезно, когда нужно гарантировать, что один поток завершил свою работу перед тем, как продолжить выполнение основного потока.

#### Основной принцип работы

Когда внутри потока вызывается метод `join()` для другого потока, текущий поток (в котором вызван `join()`) приостанавливается и ждёт завершения работы потока, на котором был вызван `join()`.

```java
thread1.join();
thread2.join();
```

Эти строки означают, что текущий поток (например, `main`) будет ждать, пока `thread1` и `thread2` не завершат свою работу. Только после этого выполнение текущего потока продолжится.

#### Варианты использования `join`

1. **Без параметров:**
   ```java
   thread.join();
   ```
   В этом случае текущий поток будет ждать, пока поток `thread` полностью завершит своё выполнение.

2. **С параметром (в миллисекундах):**
   ```java
   thread.join(1500);
   ```
   Здесь текущий поток будет ждать завершения потока `thread` либо до тех пор, пока `thread` не завершит работу, либо пока не пройдёт 1,5 секунды (1500 миллисекунд). После истечения указанного времени текущий поток возобновит своё выполнение, даже если поток `thread` всё ещё работает.

#### Пример использования `join`

```java
class MyThread extends Thread {
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Поток " + Thread.currentThread().getName() + " работает");
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Example {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();

        thread1.start();
        thread2.start();

        try {
            thread1.join();  // Ждём завершения потока thread1
            thread2.join();  // Ждём завершения потока thread2
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Оба потока завершили работу, продолжаем выполнение main");
    }
}
```

#### Особенности `join`

- **Управление последовательностью выполнения:** Метод `join()` полезен для управления порядком выполнения потоков, особенно когда необходимо дождаться завершения определённого потока перед продолжением выполнения программы.
  
- **Возможность использования с тайм-аутом:** Вариант использования с параметром (в миллисекундах) позволяет ограничить время ожидания и избежать бесконечного ожидания в случае проблем с потоком.



