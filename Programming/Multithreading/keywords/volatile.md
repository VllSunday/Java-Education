---
создал заметку: 2024-08-22
---
Ваш конспект по теме `volatile` выглядит достаточно хорошо, но есть несколько моментов, которые можно дополнить или уточнить. Я добавлю недостающие детали и немного упорядочу текст. Вот улучшенная версия вашего конспекта:

---

## Конспект на тему `volatile`

### Введение

При запуске одной и той же программы мы можем наблюдать, что вывод в консоли различается. Это происходит потому, что порядок выполнения потоков непредсказуем и зависит от многих факторов, таких как количество ядер процессора и их загрузка. В некоторых случаях нам нужно обеспечить упорядоченность действий потоков, что достигается через синхронизацию. О синхронизации мы поговорим позже. Начнем с ключевого слова `volatile`.

### Ключевое слово `volatile`

Ключевое слово `volatile` используется для указания, что переменная может быть изменена разными потоками. Это означает, что значение переменной будет всегда читаться из основной памяти (Main Memory) и записываться в нее, а не из кеша процессора.

#### Пример:

```java
public class VolatileEx extends Thread {  
    boolean b = true;  
  
    @Override  
    public void run() {  
        long counter = 0;  
        while (b) {  
            counter++;  
        }  
        System.out.println("Loop finished. Counter: " + counter);  
    }  
  
    public static void main(String[] args) throws InterruptedException {  
        VolatileEx thread = new VolatileEx();  
        thread.start();  
        Thread.sleep(3000);  
        System.out.println("After 3 sec time to wake up!");  
        thread.b = false;  
        thread.join();  
        System.out.println("End of program");  
    }  
}
```

В этом примере создается класс `VolatileEx`, который наследуется от `Thread`. Переменная `b` по умолчанию установлена в `true`. Метод `run` запускает бесконечный цикл, пока `b` остается `true`. Когда `b` изменяется на `false`, цикл прерывается, и выводится значение счётчика.

В методе `main` создается и запускается поток `thread`. Программа приостанавливается на 3 секунды, после чего `b` устанавливается в `false`, останавливая цикл в потоке `thread`. После завершения потока выводится сообщение об окончании программы.

Однако в данном коде отсутствует ключевое слово `volatile`, что может привести к проблемам с видимостью изменений переменной `b` между потоками.

### Как это работает на самом деле?

В многопоточных программах потоки могут использовать кэш процессора для хранения значений переменных для ускорения доступа. Когда переменная изменяется в одном потоке, новое значение может быть записано в кэш процессора, но не сразу обновляется в основной памяти. Таким образом, другие потоки, работающие с переменной, могут читать старое значение из своего кэша.

В нашем примере переменная `b` может быть изменена в основном потоке (main) на `false`, но этот результат может не быть немедленно виден потоку `thread`, если значение переменной `b` хранится только в кэше процессора, а не в основной памяти.

Чтобы избежать таких проблем, используется ключевое слово `volatile`. Когда переменная помечена как `volatile`, её значение всегда будет храниться в основной памяти и каждый поток будет читать и записывать значение переменной непосредственно из основной памяти.

### Важное замечание

Переменная `volatile` работает корректно, если один поток её изменяет, а другие потоки только читают. Когда несколько потоков могут изменять значение переменной, требуется дополнительная синхронизация.

#### Пример:

Если заменить булеву переменную `b` на `int a` и сделать её `volatile`, а оба потока выполняют операцию `a++`, то это может привести к проблемам. Операция `a++` не является атомарной, так как состоит из нескольких шагов:

1. Прочитать текущее значение `a`.
2. Увеличить значение.
3. Записать новое значение в основную память.

В результате, два потока могут читать одно и то же значение, увеличивать его и записывать одно и то же обновленное значение в основную память, что приводит к потере данных.

Таким образом, для корректной синхронизации, когда несколько потоков изменяют переменную, используются другие техники синхронизации, такие как блокировки или атомарные переменные.

### Заключение

Использование ключевого слова `volatile` позволяет обеспечить корректное чтение и запись переменной между потоками, но не решает всех проблем многопоточности, таких как атомарные операции. Для более сложных случаев требуется дополнительная синхронизация.

---


### Личный конспект

Эту версию можно скопировать и вставить в Obsidian. Если есть еще вопросы или нужно что-то уточнить, дайте знать!

До этого мы не однактратно убеждались в том, что при запуске 1-й и той же программы, в консоли постоянно были разные output-ы.

То есть мы заранее не могли знать какая часть первого потока, сначала обработается, когда начнет работать другой поток,  когда он перехватит инициативу и тд. Это все зависит то кол-во ядер, какова их заграженость и тд.

При решении большинства задач, нам нужно что бы сохранялась упорядочиность в действиях наших потоков. Это достигается за счет их синхронизации. 
О синхронизации, мы будет говорить немного позже. 

Начнем пока что с keyword "volatile"

volatile - изменчивый, не постоянный


### Пример:

```java
public class VolatileEx extends Thread{  
    boolean b = true;  
  
    @Override  
    public void run() {  
        long counter = 0;  
        while(b){  
            counter++;  
        }  
        System.out.println("Loop finished. Counter: " + counter);  
    }  
  
    public static void main(String[] args) throws InterruptedException {  
         VolatileEx thread = new VolatileEx();  
         thread.start();  
         Thread.sleep(3000);  
        System.out.println("After 3 sec time to wake up!");  
        thread.b = false;  
        thread.join();  
        System.out.println("End of programm");  
    }  
}
```

В данном коде создаётся класс `VolatileEx`, который наследуется от `Thread`. Внутри класса есть булевая переменная `b`, которая по умолчанию установлена в `true`. Метод `run` запускает бесконечный цикл, который увеличивает счётчик `counter`, пока переменная `b` остаётся `true`. Когда переменная `b` изменяется на `false`, цикл прерывается, и выводится сообщение с текущим значением счётчика.

В методе `main` создаётся и запускается поток `thread`. Программа приостанавливается на 3 секунды, после чего переменная `b` устанавливается в `false`, останавливая цикл в потоке `thread`. После завершения потока выводится сообщение об окончании программы.

Однако в данном коде отсутствует ключевое слово `volatile`, что может привести к проблемам с видимостью изменений переменной `b` между потоками.


### Как все работает на самом деле? 

 В многопоточных программах где потоки работают с переменными. Каждый поток может скопировать значение переменной, из ==общей памяти== (MAIN MEMORY) в ==cache cpu ==

У нас есть несколько потоков, которые работают на разных ядрах нашего процессора.
И для ускорения работы с переменными, они могу скопировать значения переменной, каждый в свой cache cup. Это делается для быстрого доступа. Cache это очень быстрая область памяти. Что бы ядру каждый раз не обращаться к общей памяти, у него есть свой cache, он копирует значения переменных туда.


Как было в нашем примере: 
У нас есть переменная b = true 
Соответственно в chach помещается значение true, для нашей переменной b


В какой то момент времени, а именно через 3 секунды в потоке main мы меняем значение переменной b на false. Это значение храниться в cache-e

И самое главное заключается в том что мы не знаем когда измененное значение переменной b вновь попадет в MAIN MEMORY 

И когда cpu 1 cache прочитает это значение и изменит его на fasle соответственно. Мы не можем вообще знать когда это может произойти 

То есть у нас возникла ситуация когда во всех областях памяти b = true. Когда мы меняем его значение на false оно меняется только в cpu 2 cache. С которым работает поток main. А в cpu 1 cache находится b = true;

Потому что: cpu 1 cache - связан с Main тоже, но в Main Memory не получила новые данные от cpu 2 cache.

Поэтому наш цикл продолжает крутиться не смотря на то что в main потоке мы поменяли наше значение на false.
![[Pasted image 20240822130659.png]]

Что бы избежать этой ситуации мы используем ключевое слово volatile для переменной.

Когда наше переменна volatile, ее значение будет храниться только в main memory.
cpu 1 cache и cpu 2 cache не будут хранить значение переменной b.

И когда потокам thread или main нужно будет поработать с переменной b , они будут обращаться не к своему cache а на прямую в ==Main Memory==. В этом и суть ключегого слова volatile.

Переменные volatile храняться не в кэше а в Main Memory(Основной памяти) 

И тогда рассинхронизации в значении данной переменно среди потоков не будет

## Важное замечание: 

Мы поняли что наш пример, отлично работает, но стоит учесть следующее: 

volatile переменная работает корректно когда у нас только 1 поток ее изменяет а другой или множества других потоков только читают 

### Рассмотрим следующий пример: 

Заменим нашу переменную b на int a = 0;

Переменная a будет volatile, то есть значение переменной будет храниться в Main Memory.

И представим что оба наших потока (thread & main) выполняют операцию a++

Это операция не Атомарная 
		#АтомарнаяОперация - "Атомарная операция" означает операцию, которая кажется мгновенной с точки зрения всех других потоков. Вам не нужно беспокоиться о частично завершенной операции, когда применяется гарантия.
То есть это операция состоит из нескольких частей 

Что бы увеличить переменную ==a== какие шаги мы должны сделать?
Вообще что такое a++ |  это тоже самое что и a = + 1;
1) Прочесть значение  (a = 0)
2) Увеличить (a = 1)
3) Записать значение в Main Memory (a = 1)
Операция a++ состоит из 3 шагов и не является атомарной 

К чему это можешь привести? 
Например a = 5;
Первый поток начал записывать, значение, 
Второй поток тоже записал значение 5.
Но потом первый поток вернул уже 6 и записал 6 а значение. 
Потом завершился второй поток и он так же записал 6
Но нам не подходит такой расклад. Мы ожитали что если они будут работать паралельно, и значение увиличется на 2

Как понятно из этого примера: volatile переменная работает корректно когда у нас только 1 поток ее изменяет а другой или множества других потоков только читают 

Для достижения синхронизации потоков, когда несколько из них могу менять значения нашей переменной, используются другие техники синхронизации.