---
создал заметку: 2024-08-22
---
Мы рассмотрим - Data race и synchronized методы. Рассмотрим технику синхронизации потокотов, когда в нашем приложении несколько потоков хотят менять значения какой то переменной. То есть потоки могу ==одновременно== менять какие то данные. И из за того что 
вот эти изменения данных, происходят одновременно, это может по влечь за забой не желательные последствия

### Пример

```java
public class Ex10 {  
    public static void main(String[] args) {  
        MyRunnableImpl1 runnable = new MyRunnableImpl1();  
        Thread thread1 = new Thread(runnable);  
        Thread thread2 = new Thread(runnable);  
        Thread thread3 = new Thread(runnable);  
        thread1.start();  
        thread2.start();  
        thread3.start();  
    }  
}  
  
class Counter {  
    volatile static int count = 0;  
}  
  
class MyRunnableImpl1 implements Runnable {  
    public void increment (){  
        Counter.count++;  
        System.out.print(Counter.count + " ");  
    }  
  
    @Override  
    public void run() {  
        for (int i = 0; i < 3; i++) {  
            increment();  
        }  
    }  
}
```
---
# Data Race 

Data race - это проблема, которая может возникнуть
когда два и более потоков обращаются к одной и той же
переменной и как минимум 1 поток её изменяет.

Когда 2 и более потоков, меняют и обращаются к переменной, мы можем столкнуться с ситуацией под названием Data Race .
Data Race переводится как гонка данных, то есть потоки как будто участвуют в гонке, и пытаются по быстрее проделать свои операции. У кого то получается быстрее у кого то медленее 
![[Pasted image 20240822152127.png]]

После того того как мы прочитали изменили и записали значение переменной count в Main Memory 

Что бы вывести на экран значение из counter, мы снова должны прочитать значение из Main Memory и вывести в консоль.

Допустим все потоки прочитали значение 3. Они работают параллельно и такое тоже может быть.
Эти три потока работают не с одинаковой скоростью, так как на выполнение работы, им могут даваться разной загруженности ядра, то есть у потоков разная почти всегда разная скорость. В следствии чего они прочли значение 3. 

Первый поток увеличил значение на 4, записал в память, но еще не вывел на экран.
То есть первый поток изменил значение с 3 на 4 но еще этого изменения не видно, так как оно не было выведено на экран

Тем временем 2-й самый шустрый поток, успел 3 раза проделать все свои операции, то есть в итоге записать в память значение 6. 
Как это произошло? 
Он 3-ды делал свою операцию 
4 заменил на 4 | вывел на экран 4
4 заменил на 5 | вывел на экран 5
5 заменил на 6 | вывел на экран 6

После чего, например первый поток, у которого еще на первой итерации System.out.println не сработал, он все же хочет завершить свою итерацию. По этому ему нужно вывести на экран count. Он обращается к Main Memory смотрит что значение равно 6, и снова выводит на экран 6 

То есть   4 5 6 | вывел Thread 2 
        6       | вывел Thread 1

Третий поток, который работает медленнее всего меняет значение с 3 на 4, записывает 4 и выводит 4 на консоль
И получается следующее: 
То есть   4 5 6 | вывел Thread 2 
        6       | вывел Thread 1
        4       | вывел Thread 3



# 

Как можно решить проблему Data Race? 

Чтобы избегать этой проблемы, мы должны быть уверенны в том что в один момент времени с переменной counter будет работать только один поток. Что бы несколько потоков не могли обращаться одновременно.

Как этого можно добиться?

Можно поставить Lock(замок) на необходимый участок кода и теперь в одно и тоже время только 1 thread сможет выполнять наш метод или участок кода, на который был поставлен замок

### Как это работает? 

У нас есть метод increment() 

И есть 3 потока: 
Th 1
Th 2
Th 3

Если мы захотим поставить замок на весь метод increment() 
Тогда только один thread будет исполнять тело increment() 

Как еще можно это объяснить? 

Можно представить так: 
Забежал в тело метода: поток(Th 1) 
Замок закрылся, и он не будет открыт до тех пор пока не будет завершено тело метода 

А другие потоки (Th 2 и Th 3) будут стоять и ждать 

В этом и принцип ==синхронизации==

После того как метод будет выполнен, а замок открыт. 
Другие потоки будут пытаться залезть потоки (Th 2 & Th 3)

Какому из них больше повезет, или приоритет у которого выше. 
Он опять забегает в тело метода. Закрывает замок. До тех пор пока не выполнит тело метода

Таким образом Access(доступ) к переменной counter есть только у 1 потока за раз

![[Pasted image 20240822162102.png]]