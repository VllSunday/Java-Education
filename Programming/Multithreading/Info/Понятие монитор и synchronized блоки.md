---
создал заметку: 2024-08-22
---
# Что такое монитор

Монитор - это специальный механизм, благодаря которому достигается корректная работа при синхронизации.
У каждого класс или объекта в Java есть привязанная к нему сущность, называемая "монитор"
 
Монитор может иметь статут свободен или занят

Именно этот механизм используется в Java когда мы пишем keyword Synchronized 

Таким образом когда один поток заходит в область кода которая помечена как Synchronized.

Монитор объекта или класса принимает состояние занято.

В одно и тоже время монитор может заниматься только 1-м потоком

Теперь больше не один поток до того как монитор не перейдет в состояние свободен не сможет работать с этим кодом.


Например, у нас есть 3 потока.
T1 & T2 & T3

Если Т2 займет монитор быстрее чем все остальные, но скажет что монитор занят мною.

И пока T2 не освободит монитор T1 и T3 потоки будут ждать, и когда монитор освободиться они уже будут бороться за монитор.


Другими словами, когда монитор становиться занятым, происходит lock(закрытие, или запирание)

После того как поток завершил выполнение lock снимается до тех пор пока в метод помеченный как synchronized не заберется следующий поток и не закроет его.

То есть мы как бы закрываем дверь когда монитор занят.
Открываем дверь когда монитор свободен

## Очень важное замечание

Следует запомнить что: Любая блокировка с помощью синхронизации идет на объекте или на классе, а не на каком то коде.

То есть мы синхронизируемся используя монитор объекта или класса.
То есть синхронизация идет на этом уровне, благодаря монитору объекта или класса

Да мы пишем synchronized методы, но у метода не ни какого монитора

Для синхронизации метода используется мониторы объекта или класса

![[Pasted image 20240822165846.png]]


# Synchronized блоки

Synchronized блоки работают также как и Synchronized методы. Только обычно они синхронизируют не весь код в методе, а лишь его часть

### Пример

Синхронизированный метод: 
```java
public synchronized void doWork1(){  
        Counter2.count++;  
        System.out.println(Counter2.count);  
}
```

Синхронизированный блок:
```java
public void doWork1(){  
    synchronized (this){  
        Counter2.count++;  // синхронизированная строка
        System.out.println(Counter2.count);  // синхронизированная строка
    }  
}
```

#### Синтаксис: 
- Пишем например внутри метода слово: ==synchronized== далее идут скобки, внутри которых мы пишем объект(или название класса) на котором мы будем синхронизироваться. То есть объект, чей монитор для синхронизации мы будем использовать (лочить и анлочить)

```java
synchronized (this) { ... }
```

В нашем случаем синхронизация будет проходить на объекте "this". То есть когда вызывается метод doWork (не статичный), по этому придется создать объект класса MyRunnableIml.
И синхронизация будет вестить на объекте этого класса 


### Важный вопрос: 

Когда мы пишем synchronized у метода

```java
public synchronized void doWork1()
```

-Монитор какого то объекта или класса используется? 

ДА, кончено!! Иначе просто не как

Просто когда мы используем synchronized метод мы явно не указываем этот объект/класс

А когда мы используем synchronized блок, мы должны мы должны в скобках указать монитор какого класса будет использоваться для синхронизации

Когда мы работаем с synchronized методами и метод ==не статичный==, то всегда синхронизация идет на объекте ==this== 

Когда мы используем ключевое слово  synchronized на статичном методе, то тогда используется монитор всего класса
Пример:
```java
public static void doWork(){
	synchronized (SynchronizedBlock2.class){
		counter++;
	} 
}
```
Важно указывать 

### Чем отличается synchronized метод от блока? 

Самое главное отличие синх.блока заключается в том что мы можем синхронизировать не весь метод а только часть метода 

Пример

```java 
private void doWork2(){  
    System.out.println("Ura!!!!");  
}  
  
public void doWork1(){  
    doWork2();  
    synchronized(this) {  
        Counter2.count++;  
        System.out.println(Counter2.count);  
    }  
}
```

Мы создали новый метод doWork2, и сделали синхоронизацию только блока в методе doWork1

Получается потоки который захотят использовать использовать doWork2 могу это делать как им захочиться. 
Но как только дело дойдет до метода до синхронизированного блока, всем придется встать в очередь.


То есть если мы уверенны что код в doWork2 не вызовет ошибок связанных с Data Race, то почему бы не дать выполниться этому коду не зависимо от того какой поток будет это делать? 

# Самое главное

Нужно запомнить раз и навсегда:  Синхронизация идет по по монитору, а монитор это не отъемлемая часть каждого объекта и каждого класса в Java 


###  Задача:

Необходимо реализовать систему, в которой в любой момент времени на телефон может звонить только одно приложение (например, Skype, WhatsApp, Mobile)

Для этого нужно сделать так что бы потоки обращались к одному монитору. 

Для того что бы сделать такой функционал, мы можем сделать просто:
По стандарту в Java принято делать вот так

```java
private static final Object LOCK = new Object();
```

То есть просто создать LOCK для того чтобы использовать его монитор для того чтобы только один звонок мог быть совершенным.

Вот пример, гибкого кода: 
Это всего лишь 1 пример того можно реализовать интерфейс CallableApp
```java
public class MobileApp implements CallableApp {  
    @Override  
    public void call() {  
        System.out.println("Mobile call start.. ");  
  
        try {  
            Thread.sleep(5000);  
        } catch (InterruptedException e) {  
            throw new RuntimeException(e);  
        }  
  
        System.out.println("Mobile call end");  
    }  
}
```

Далее мы делаем класс который будет отвечать за метод звонок. Самое интересное, что нам не важно с чего будет совершен звонок
```java
public class CallManager {  
    private static final Object LOCK = new Object();  
  
    public void call(CallableApp app){  
        synchronized(LOCK) {  
            app.call();  
            try {  
                Thread.sleep(2000);  
            } catch (InterruptedException e) {  
                Thread.currentThread().interrupt();  
            }  
        }  
    }  
}
```

Далее мы просто создаем класс который может быть потоком:

```java
public class CallTask implements Runnable{  
    private final CallManager callManager;  
    private final CallableApp app;  
  
    public CallTask(CallManager callManager, CallableApp app) {  
        this.callManager = callManager;  
        this.app = app;  
    }  
  
    @Override  
    public void run() {  
        callManager.call(app);  
    }  
}
```

И деле мы просто запускаем наши потоки:

```java
public class TestCall {  
    public static void main(String[] args) {  
        CallManager manager = new CallManager();  
  
        Thread thread1 = new Thread(new CallTask(manager, new SkypeApp()));  
        Thread thread2 = new Thread(new CallTask(manager, new Whatsapp()));  
        Thread thread3 = new Thread(new CallTask(manager, new MobileApp()));  
  
        thread1.start();  
        thread2.start();  
        thread3.start();  
  
    }  
}
```

Все работает как надо!!!



