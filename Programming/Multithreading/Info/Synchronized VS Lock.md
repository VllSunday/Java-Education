---
создал заметку: 2024-08-23
---
Конструкции `synchronized` и `Lock` (в частности, `ReentrantLock`) в Java используются для обеспечения синхронизации между потоками, но у них есть различия в возможностях и применении. Давай рассмотрим их отличия, а также их плюсы и минусы.

### `synchronized`

**Описание:**
- `synchronized` — это ключевое слово, встроенное в язык Java, которое обеспечивает автоматическую синхронизацию блоков кода или методов. Оно использует монитор объекта для управления доступом к критической секции.

**Плюсы:**
1. **Простота использования:** Легко понять и использовать для блокировки доступа к критическим секциям.
2. **Автоматическое управление:** Освобождение блокировки происходит автоматически при выходе из блока/метода, что снижает риск забыть освободить блокировку.
3. **Поддержка рекурсии:** Если поток уже владеет монитором, он может повторно войти в синхронизированный метод/блок того же объекта (рекурсивная блокировка).
4. **Нативная поддержка:** `synchronized` — это часть самого языка Java, что обеспечивает высокую производительность и надежность.

**Минусы:**
1. **Менее гибкий:** `synchronized` не предоставляет дополнительных возможностей, таких как попытка захвата блокировки (`tryLock()`), таймауты, справедливость очереди потоков и т. д.
2. **Нет возможности прервать блокировку:** Поток, ожидающий захвата блокировки, не может быть прерван до тех пор, пока монитор не будет освобожден.
3. **Жесткость управления:** Все действия с блокировкой строго зависят от монитора объекта, без возможности гибкого управления.

### `Lock` (например, `ReentrantLock`)

**Описание:**
- `Lock` — это интерфейс, предоставляющий более гибкие и сложные возможности для управления синхронизацией потоков по сравнению с `synchronized`. `ReentrantLock` — одна из его наиболее используемых реализаций.

**Плюсы:**
1. **Более гибкое управление:** `Lock` предоставляет методы, такие как `lock()`, `tryLock()`, `lockInterruptibly()` и `unlock()`, что позволяет более гибко управлять блокировками.
2. **Таймауты и прерывания:** Возможность прерывать попытки захвата блокировки (`lockInterruptibly()`) и использовать таймауты при попытке захватить блокировку (`tryLock(long timeout, TimeUnit unit)`).
3. **Справедливость очереди:** Можно создать `ReentrantLock` с флагом справедливости, чтобы потоки получали доступ к блокировке в порядке поступления (FIFO).
4. **Условные переменные:** Поддержка объектов условных переменных (`Condition`), что позволяет более гибко управлять уведомлением и ожиданием потоков.

**Минусы:**
1. **Ручное управление:** Необходимо явно освобождать блокировку с помощью метода `unlock()`, что увеличивает риск возникновения ошибок, таких как забытая разблокировка.
2. **Более сложный код:** Использование `Lock` требует большего количества кода и внимательности, что может усложнить программу.
3. **Нет автоматической поддержки рекурсии:** Хотя `ReentrantLock` поддерживает рекурсивную блокировку, не все реализации `Lock` это делают по умолчанию.

### Вывод

- **Когда использовать `synchronized`:** Если у тебя простая задача синхронизации и тебе не нужно ничего сверх базового управления блокировкой, `synchronized` — это простой и надежный выбор.
  
- **Когда использовать `Lock`:** Если требуется более гибкое управление синхронизацией, такие как возможность прерывания потока при захвате блокировки, использование таймаутов, справедливости доступа к ресурсам или условных переменных — лучше использовать `Lock`. 

Обе конструкции имеют свои плюсы и минусы, и выбор зависит от требований конкретной задачи.