---
создал заметку: 2024-08-25
---
Получаются из традиционных коллекций благодаря их обертыванию 

Платформа Java Collection является одним из основополагающих компонентов языка Java. Коллекции представляют собой группу объектов, а Java предоставляет несколько интерфейсов и реализаций для работы с этими коллекциями. С появлением многопоточного программирования возросла потребность в потокобезопасных коллекциях. Именно тогда в структуру Java Collection были добавлены синхронизированные коллекции.

### Как синхронизированные коллекции обеспечивают потокобезопасность?

Синхронизированные коллекции (Synchronized Collections) обеспечивают потокобезопасность за счет принудительной синхронизации каждого из общедоступных методов. Кроме того, это гарантирует, что его внутреннее состояние никогда не будет опубликовано. То есть, единственный способ изменить коллекцию — это использовать ее общедоступные синхронизированные методы! Синхронизированные коллекции можно представить, как простые несинхронизированные коллекции с инкапсуляцией состояния и синхронизированными общедоступными методами. Поскольку одна и та же (внутренняя) блокировка защищает каждый общедоступный метод синхронизированной коллекции, какие-либо два потока ==не могут изменять/читать коллекцию одновременно==. Это гарантирует, что коллекция всегда сохранит свои варианты и, следовательно, станет потокобезопасной.

### Как создавать синхронизированные коллекции

Класс Collections предоставляет несколько статических методов для создания синхронизированных коллекций. Эти статические методы имеют имена в следующем формате — synchronizedXxx. Вот список этих методов:

- synchronizedCollection(Collection`<T>` c)
- synchronizedList(List`<T>` list) 
- synchronizedMap(Map`<K, V> `m)
- synchronizedNavigableMap(NavigableMap<K, V> m)
- synchronizedNavigableSet(NavigableSet`<T>` s)
- synchronizedSet(Set`<T>` s)
- synchronizedSortedMap(SortedMap<K, V> m)
- synchronizedSortedSet(SortedSet`<T>` s)

Теперь мы создадим синхронизированный список, используя класс Collections.

```java
List<Integer> synchronizedIntegerList = Collections.synchronizedList(new ArrayList<>());
```

### Synchronized collections vs Cuncurrent collections
Обычно Synchronized collections медленнее чем Cuncurrent collections


### Пример создания потокабезопастного  ArrayList

```java
public class SynchronizedCollectionEx {  
    public static void main(String[] args) throws InterruptedException {  
        ArrayList<Integer> source = new ArrayList<>();  
        for (int i = 0; i < 5; i++) {  
            source.add(i);  
        }  
  
        List<Integer> synchList = Collections.synchronizedList(new ArrayList<>());  
        Runnable runnable = () -> synchList.addAll(source);  
  
        Thread thread1 = new Thread(runnable);  
        Thread thread2 = new Thread(runnable);  
  
        thread1.start();  
        thread2.start();  
        thread1.join();  
        thread2.join();  
  
        System.out.println(synchList);  
    }  
}
```

Здесь показано как именно работает ArrayList который был создан с помощью 
==Collections.synchronizedList== в данном метод addAll (как и все методы Array List который был создан с помощью ==Collections.synchronizedList==) является залоченым. И только 1 поток в 1 время может что то делать с коллекцией.

### Ловушка при работе с синхронизированными коллекциями

Хотя методы, предоставляемые из синхронизированных коллекций, являются потокобезопасными, действия на стороне клиента по-прежнему требуют надлежащей блокировки. Рассмотрим следующий пример кода:

```java
public void putIfAbsent(List<Integer> synchronizedList, Integer elem) {    if(!synchronizedList.contains()) {
		synchronizedList.add(elem);
	} 
}
```

Этот невинный на вид метод небезопасен для потоков! Даже с потокобезопасными методами contains и add, метод putIfAbsent не достигает того, для чего он предназначен. Между шагами “проверка” и “действие” нашего метода другой поток может добавить elem в список. Ответственность за защиту от таких случаев лежит на клиенте. Синхронизированные коллекции позволяют блокировать на стороне клиента, чтобы гарантировать, что такие составные действия являются атомарными по отношению к другим операциям. Каждый общедоступный метод синхронизированной коллекции защищен внутренней блокировкой. Таким образом, клиент может создавать атомарные операции, получая ту же блокировку. Вот как мы исправим ситуацию с putIfAbsent с помощью блокировки на стороне клиента.

```java
public void putIfAbsent(List<Integer> synchronizedList, Integer elem) { synchronized(synchronizedList) {
		if(!synchronizedList.contains()) { 
			synchronizedList.add(elem); 
		}
	} 
}
```

### Подводные камни итерации синхронизированных коллекций

При переборе синхронизированной коллекции необходимо проявлять особую осторожность. Если вы при таком переборе используете итераторы, то любые одновременные изменения приведут к быстрому сбою этого итератора. В частности, при обнаружении любой параллельной модификации итератор выдаст исключение ConcurrentModificationException.

```java
final Set<String> syncStringSet = Collections.synchronizedSet(new HashSet<>()); // Может вызвать исключение ConcurrentModificationException 
for(String s: syncStringSet) {
	doSomething(s); 
}
```

Чтобы избежать выброса исключения ConcurrentModificationException, мы можем удерживать блокировку синхронизированной коллекции на протяжении всей итерации. Конечно, что это не самый эффективный подход, поскольку итерация может занять много времени и заблокирует доступ к коллекции другим выполняющимся потокам. Помните, что синхронизированные классы предоставляют простой механизм, позволяющий сделать классы коллекций потокобезопасными. Их глубокое понимание поможет вам избежать многих распространенных ошибок!