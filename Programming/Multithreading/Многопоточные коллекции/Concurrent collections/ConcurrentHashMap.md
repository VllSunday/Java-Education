---
создал заметку: 2024-08-25
---
ConcurrentHashMap имплементирует интерфейс
ConcurrentMap, который в свою очередь происходит от
интерфейса Мар.

В ConcurrentHashMap любое количество потоков может
читать элементы не блокируя его.

В ConcurrentHashMap, благодаря его сегментированию,
при изменении какого-либо элемента блокируется
только bucket, в котором он находится.

В ConcurrentHashMap не key, не value не могут быть null

---

![[Pasted image 20240825203356.png]]

Например, мы заблокировали сегмент номер 3. Все остальные 15 сегментов доступны для использования.

То что сегмент 3 занят выполнением какого то потока, означает что он сейчас ==залочен==

Такой _вид_ локинга называется ==segmentLocking== или ==bucketLocking==

По итогу все просто если у нас 16 бакетов, то 16 потоков, могут одновременно изменять элементы нашего ConcurrentHashMap.

То есть CuncurrentHashMap из за его сегментированности можно рассматривать как группу HashMap-ов  (как 16 HashMap)

Из за всех этих преимуществ CunccurentHashMap работает намного быстрее чем synchronizedMap(new HashMap());