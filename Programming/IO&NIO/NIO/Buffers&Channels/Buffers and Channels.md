---
создал заметку: 2024-08-18
---
### Важно сказать
Используя пакет ==NIO== мы можем работать не только с файлами, но и сетью и тд

 Основные принципы работы с Buffer и Channel:

![[Buffer&Channel.png]]

Чтение файла: ==Channel== читает информацию из файла и
записывает в ==Buffer==.
_Запись_ в файл: ==Channel== читает информацию из ==Buffer== и
записывает её в файл.

На самом деле Channel и поток чем то похожи. Но в отличии от стримов Channel может как читать файл, так и записывать в него

Вообще NIO & IO очень богатые API, и например видов Channel есть очень много, так что. 
Например: DataGram channel,  socket channel, serves socket channel

К слову, буферы тоже бывают разные. 
Например: CharBuffeer, FloatBuffer, DoubleBuffer и тд..

В основном мы будем работать с ByteBuffer & FileChannel

### Для начала, можно рассмотреть пример: 
```java
public static void main(String[] args) {  
    try (RandomAccessFile file = new RandomAccessFile("test10.txt", "rw");  
         FileChannel channel = file.getChannel();){  
        ByteBuffer buffer = ByteBuffer.allocate(25);  
          
  
    } catch (FileNotFoundException e) {  
        throw new RuntimeException(e);  
    } catch (IOException e) {  
        throw new RuntimeException(e);  
    }  
}
```

Мы тут видим, что бы взаимодействовать с ==_file_== мы создаем channel 

Команда: FileChannel channel = file.getChannel()
Означает что мы получили канал из файла.

Далее мы создаем буффер. Который мы еще и ограничили в 25 байт.

### Код:
```java
try (RandomAccessFile file = new RandomAccessFile("test10.txt", "rw");  
     FileChannel channel = file.getChannel();){  
    ByteBuffer buffer = ByteBuffer.allocate(25);  
    StringBuilder poem = new StringBuilder();  
  
  
    int read = channel.read(buffer);  
  
    while(read > 0) {  
        System.out.println("Byte Read: " + read);  
  
        buffer.flip();  
    }  
}
```
Теперь у нас есть вот такое код

Для того что бы считать текст из файла "test10.txt"
Нужно этот текст считать в буффер. Как мы помним мы не взаимодействуем с Buffer на прямую. По этому мы используем: ==int read = channel.read(buffer);==

То есть мы читаем по(или из(не знаю)) каналу в буфер.
И этот код, возвращает число байт записанных в буфер. 

Далее мы просто пишем, что если кол-во записанных в буфер данных > 0 то значит данные для считывания (то есть текст) еще не закончился. 
И если еще есть что считывать, мы выводим кол-во записанных байт в буфер. 


Далее нужно немного отвлечься для того что бы понять один интересный метод, а именно: 
==buffer.flip()==

### Flip - переводиться как кувырок или сальто
В данном коде ==buffer.flip()== можно считать что мы делам кувырок назад


### Разбор: 
![[Buffer&Channel1.png]]


Вот наш буфер! 
Буфер может бы в режиме записи (write) и в режиме(read)

Еще раз, буфер это такой блок памяти, который может быть использован как для записи так и для чтения.

Буфер имеет 3 очень важных понятия, которые нужно знать

1) capacity
2) position
3) limit

Понятия position и limit, зависят от того, записываем ли мы сейчас в буфер что то или читаем из него.

capacity - всегда означает одно и тоже.

Как показано на картинке, мы работает с файлом который занимает 23 байта.

Так же мы создали буфер, используя вот такой код: 
```java
ByteBuffer = ByteByffer.allocate(10);
```
То есть наш буфер может содержать 10 байт

### Что такое capacity ?
Как мы говорили что буфер это блок памяти, который имеет определенный размер.
Этот определенный размер так же называют ==capacity== 

Если речь идет о ByteBuffer то мы можем записать в наш Buffer кол-во байтов не привышающего его вместимость (capacity)
А данном случае capacity равен 10


### Write 
Сейчас мы будем говорить о Write Mode
Наш буфер содержит 10 мест для записи байтов.
Будем считать что отсчет начинается с верху от 0 до 9
	
![[WriteMode.png]]

Когда мы что то записываем в буфер, мы делаем эту запись на определенную позицию (position)
Изначально Position = 0 
При записи (в данном случае байтов) в буфер, позиция меняется. 
То есть если изначаль Position = 0, то после записи в 0, Position поменяется на 1 и т.д

Максимальная Position = Capacity - 1


### Read 
Когда мы читаем информацию из буфера, мы читаем информацию из определенной ячейке в буфере  

Наш файл содержит 23 байта.

Допустим, мы записали 10 байтов в наш буфер. - Что это означает? 

Что position  = 10
То есть после заполнения буфера мы находится на позиции 10
Куда больше написать мы написать ничего не можем, потому что выбраситься excetion

После того как мы записали в буфер, мы хотим из него читать.

Но мы не можем начать читать из буфера у которого position = 10 потому что на этой позиции ничего не написано.

Для того что бы не читать с позиции 10 мы вызываем метод ==flip ()==

Метод flip меняет режим буфера, из режима записи в режим чтения

Запись -> Чтение 

Position = 10 из WritingMode-> меняется на postion = 0 из ReadingMode

То есть вызовом метода flip() мы меняем позицию например и 10 на 0 позицию

И теперь мы можем начать читать наш буфер начиная из 0 позиции
Вот что делает метод flip.

Когда мы дойдем до последнего элемента в буфере и считали байт из этой позиции.

Мы вызываем метод clear();
Не нужно забывать что ранее на картинке было показано 2 таблички. Но это все равно 1 и тот же буфер, просто в разных режимах. 
И вызвал метод clear, мы не очищаем буфер, мы просто переводим наш буфер в режим чтения не 0 позицию, и новый байты которые будут записываться просто будут затирать старые


### Limit

В режиме записи, ==limit== то же самое что и capacity, то есть означает максимальное кол-во байт которое можно записать в буфер.

Когда мы делаем flip и позиция в режиме чтения из буфера равно 0.
Здесь limit означает максимальное кол-во байтов которые мы можем прочитать.

И этот limit = позиции в режиме чтения до того как был применен метод flip

То есть limit помогает понять сколько конкретно байт нужно прочитать. 
Если вы записали все 9 байт то есть position = 9, то limit в read mode тоже будет равен 9

Но если например у нас не поместилось 3 байта для полной записи файла.
То postion при записи будет 3 и соответственно limit при read будет тоже 3



Ну и вот финальный код, который у меня получился: 

```java
try (RandomAccessFile file = new RandomAccessFile("test10.txt", "rw");  
     FileChannel channel = file.getChannel();){  
    ByteBuffer buffer = ByteBuffer.allocate(25);  
    StringBuilder poem = new StringBuilder();  
  
  
    int read = channel.read(buffer);  
  
    while(read > 0) {  
        System.out.println("Byte Read: " + read);  
  
        buffer.flip();  
        while(buffer.hasRemaining()) {  
            poem.append((char)buffer.get());  
        }  
        buffer.clear();  
        read = channel.read(buffer);  
    }  
}
```

Конечно, давайте подробно разберёмся в этом коде и поймём, как работают `ByteBuffer`, `FileChannel`, и методы `flip()` и `clear()`.

### Описание работы кода

1. **Создание `ByteBuffer`:**
    ```java
    ByteBuffer buffer = ByteBuffer.allocate(25);
    ```
    Здесь создаётся объект `ByteBuffer` размером 25 байт. `ByteBuffer` — это класс, который предоставляет буфер для чтения и записи данных. В данном случае, буфер создаётся с ёмкостью 25 байт, что означает, что он может вместить до 25 байт данных одновременно.

2. **Создание `StringBuilder`:**
    ```java
    StringBuilder poem = new StringBuilder();
    ```
    `StringBuilder` используется для построения строки из прочитанных данных. Он удобен тем, что позволяет эффективно добавлять символы в конец строки.

3. **Чтение данных из канала в буфер:**
    ```java
    int read = channel.read(buffer);
    ```
    Этот метод считывает данные из канала (`FileChannel`) и записывает их в буфер (`ByteBuffer`). Метод возвращает количество байт, фактически прочитанных в буфер. Если достигнут конец файла, метод вернёт `-1`.

4. **Цикл чтения данных:**
    ```java
    while (read > 0) {
        System.out.println("Bytes Read: " + read);
        
        buffer.flip();
        while(buffer.hasRemaining()) {
            poem.append((char)buffer.get());
        }
        buffer.clear();
        read = channel.read(buffer);
    }
    ```
    Теперь давайте разберём этот цикл по частям:

    - **Проверка, что были прочитаны данные:**
        ```java
        while (read > 0) {
        ```
        Цикл продолжается, пока есть данные для чтения. Как только `read` становится равным `-1` (что указывает на конец файла), цикл завершится.

    - **Переход буфера из режима записи в режим чтения (`flip()`):**
        ```java
        buffer.flip();
        ```
        `flip()` — это метод, который используется для подготовки буфера к чтению после записи. По умолчанию, после записи данных в `ByteBuffer`, позиция указывает на первый байт после записанных данных, и `limit` указывает на максимальную ёмкость буфера. Когда вы вызываете `flip()`, позиция устанавливается в 0, а `limit` устанавливается на текущую позицию. Это означает, что теперь вы можете безопасно читать данные из буфера, начиная с его начала.

    - **Чтение данных из буфера:**
        ```java
        while (buffer.hasRemaining()) {
            poem.append((char)buffer.get());
        }
        ```
        `buffer.get()` читает один байт из текущей позиции буфера и увеличивает позицию на 1. Метод `hasRemaining()` проверяет, остались ли ещё непрочитанные байты (пока позиция меньше `limit`). Внутри этого цикла байты из буфера преобразуются в символы и добавляются к строке `poem`.

    - **Очистка буфера для следующего цикла записи (`clear()`):**
        ```java
        buffer.clear();
        ```
        После того как все данные из буфера были прочитаны, вызывается `clear()`, чтобы подготовить буфер для следующего чтения из канала. Метод `clear()` сбрасывает позицию на 0 и устанавливает `limit` на максимальную ёмкость буфера. Это делает буфер снова готовым для записи.

    - **Чтение следующей порции данных из канала:**
        ```java
        read = channel.read(buffer);
        ```
        После очистки буфера начинается чтение следующей порции данных из файла.

### Важные методы `ByteBuffer`

- **`flip()`**:
  - **Что делает**: Переключает буфер из режима записи в режим чтения.
  - **Когда используется**: После того как вы закончили записывать данные в буфер и хотите начать их читать.
  - **Как работает**: Устанавливает `limit` на текущую позицию и сбрасывает позицию на 0.

- **`clear()`**:
  - **Что делает**: Очищает буфер, переключая его обратно в режим записи.
  - **Когда используется**: После того как вы прочитали все данные из буфера и хотите записать в него новые данные.
  - **Как работает**: Сбрасывает позицию на 0 и устанавливает `limit` на максимальную ёмкость буфера.

### Как всё это работает вместе

- В начале программы данные читаются из файла и записываются в буфер с помощью `channel.read(buffer)`.
- После того как буфер заполнен данными, вызывается `flip()`, чтобы подготовить его для чтения.
- Прочитанные данные добавляются к строке `poem`.
- После чтения всех данных из буфера вызывается `clear()`, чтобы подготовить буфер для новой записи.
- Цикл повторяется, пока весь файл не будет прочитан.

--- 
### Некоторые способы записи

```java
ByteBuffer buffer1 = ByteBuffer.allocate(text.getBytes().length);  
buffer1.put(text.getBytes());  
buffer1.flip();  
channel.write(buffer1);
```

и второй: 

```java
ByteBuffer buffer2 = ByteBuffer.wrap(text.getBytes());  
channel.write(buffer2);
```



FileChannel channel = file.getChannel();
ByteBuffer buffer = ByteBuffer.allocate(100);
channel.read(buffer)
buffer.flip()
buffer.hasRemaining()
buffer.get()
buffer.clear()
buffer.put(…)
channel.write(buffer)
buffer.rewind()
buffer.compact()